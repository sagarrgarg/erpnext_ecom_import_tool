diff --git a/diff.txt b/diff.txt
index c5b9d3e..e69de29 100644
--- a/diff.txt
+++ b/diff.txt
@@ -1,2355 +0,0 @@
-diff --git a/diff.txt b/diff.txt
-index 17eec64..e69de29 100644
---- a/diff.txt
-+++ b/diff.txt
-@@ -1,296 +0,0 @@
--diff --git a/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py b/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
--index 5deba75..de1eb08 100644
----- a/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
--+++ b/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
--@@ -17,6 +17,43 @@ from datetime import datetime, timedelta
-- from frappe.utils.data import get_time
-- from frappe.utils.file_manager import get_file_path
-- from frappe.utils import flt, getdate
--+
--+def normalize_state_key(state):
--+    """Normalize state strings to match `state_code_dict` keys.
--+
--+    Why: e-commerce reports often send inconsistent values like:
--+    - "West Bengal ", "WEST  BENGAL", "West Bengal\r"
--+    - "27-Maharashtra", "27 - Maharashtra"
--+    - "Jammu & Kashmir" vs "Jammu and Kashmir"
--+    """
--+    if not state:
--+        return ""
--+
--+    key = str(state).replace("\u00a0", " ")  # NBSP -> space
--+    key = key.strip().lower()
--+
--+    # Drop leading state code prefix like "27-maharashtra" or "27 - maharashtra"
--+    if len(key) >= 3 and key[:2].isdigit():
--+        remainder = key[2:].lstrip(" -")
--+        if remainder:
--+            key = remainder
--+
--+    key = key.replace("&", "and")
--+    key = key.replace("_", " ").replace("-", " ")
--+    key = " ".join(key.split())  # collapse multiple spaces/newlines
--+    return key
--+
--+
--+def normalize_tax_rate(rate):
--+    """Normalize tax rate to the percentage ERPNext expects (e.g. 5 for 5%).
--+
--+    Some sources provide 0.05 (fraction) and some provide 5 (percent).
--+    """
--+    rate = flt(rate)
--+    if 0 < rate < 1:
--+        return rate * 100
--+    return rate
--+
-- state_code_dict = {
--     "jammu and kashmir": "01-Jammu and Kashmir",
--     "jammu & kashmir": "01-Jammu and Kashmir",
--@@ -716,10 +753,11 @@ class EcommerceBillImport(Document):
-- 								if status!="Active":
-- 									if child_row.ship_to_state:
-- 										state=child_row.ship_to_state
---										if not state_code_dict.get(str(state.lower())):
--+										place_of_supply = state_code_dict.get(normalize_state_key(state))
--+										if not place_of_supply:
-- 											error_names.append(invoice_no)
---											raise Exception(f"State name Is Wrong Please Check")
---										si.place_of_supply=state_code_dict.get(str(state.lower()))
--+											raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+										si.place_of_supply = place_of_supply
-- 
-- 								si.append("items", {
-- 									"item_code": itemcode,
--@@ -748,7 +786,7 @@ class EcommerceBillImport(Document):
-- 												si.append("taxes", {
-- 													"charge_type": "On Net Total",
-- 													"account_head": acc_head,
---													"rate":rate,
--+													"rate": normalize_tax_rate(rate),
-- 													"tax_amount": amount,
-- 													"description": tax_type
-- 												})
--@@ -850,10 +888,11 @@ class EcommerceBillImport(Document):
-- 								if status!="Active":
-- 									if child_row.ship_to_state:
-- 										state=child_row.ship_to_state
---										if not state_code_dict.get(str(state.lower())):
--+										place_of_supply = state_code_dict.get(normalize_state_key(state))
--+										if not place_of_supply:
-- 											error_names.append(invoice_no)
---											raise Exception(f"State name Is Wrong Please Check")
---										si_return.place_of_supply=state_code_dict.get(str(state.lower()))
--+											raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+										si_return.place_of_supply = place_of_supply
-- 
-- 								if not si_return.location:
-- 									si_return.location = location
--@@ -889,7 +928,7 @@ class EcommerceBillImport(Document):
-- 												si_return.append("taxes", {
-- 													"charge_type": "On Net Total",
-- 													"account_head": acc_head,
---													"rate":rate,
--+													"rate": normalize_tax_rate(rate),
-- 													"tax_amount": amount,
-- 													"description": tax_type
-- 												})
--@@ -1056,10 +1095,11 @@ class EcommerceBillImport(Document):
-- 							si.company_address = com_address
-- 							if child_row.ship_to_state:
-- 								state = child_row.ship_to_state
---								if not state_code_dict.get(str(state.lower())):
--+								place_of_supply = state_code_dict.get(normalize_state_key(state))
--+								if not place_of_supply:
-- 									error_names.append(invoice_no)
---									raise Exception(f"State name Is Wrong Please Check")
---								si.place_of_supply = state_code_dict.get(str(state.lower()))
--+									raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+								si.place_of_supply = place_of_supply
-- 							si.ecommerce_gstin = ecommerce_gstin
-- 
-- 							# ---- Append Item ----
--@@ -1093,7 +1133,7 @@ class EcommerceBillImport(Document):
-- 										si.append("taxes", {
-- 											"charge_type": "On Net Total",
-- 											"account_head": acc_head,
---											"rate": rate * 100,
--+											"rate": normalize_tax_rate(rate),
-- 											"tax_amount": amount,
-- 											"description": tax_type
-- 										})
--@@ -1214,10 +1254,11 @@ class EcommerceBillImport(Document):
-- 							si_return.company_address = com_address
-- 							if child_row.ship_to_state:
-- 								state = child_row.ship_to_state
---								if not state_code_dict.get(str(state.lower())):
--+								place_of_supply = state_code_dict.get(normalize_state_key(state))
--+								if not place_of_supply:
-- 									si_error.append(invoice_no)
---									raise Exception(f"State name Is Wrong Please Check")
---								si_return.place_of_supply = state_code_dict.get(str(state.lower()))
--+									raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+								si_return.place_of_supply = place_of_supply
-- 							si_return.ecommerce_gstin = ecommerce_gstin
-- 
-- 							hsn_code = frappe.db.get_value("Item", itemcode, "gst_hsn_code")
--@@ -1249,7 +1290,7 @@ class EcommerceBillImport(Document):
-- 										si_return.append("taxes", {
-- 											"charge_type": "On Net Total",
-- 											"account_head": acc_head,
---											"rate": rate * 100,
--+											"rate": normalize_tax_rate(rate),
-- 											"tax_amount": amount,
-- 											"description": tax_type
-- 										})
--@@ -1390,9 +1431,10 @@ class EcommerceBillImport(Document):
-- 						doc.company_address = wh.erp_address
-- 						if row.ship_to_state:
-- 							state=row.ship_to_state
---							if not state_code_dict.get(str(state.lower())):
---								raise Exception(f"State name Is Wrong Please Check")
---							doc.place_of_supply = state_code_dict.get(str(row.ship_to_state).lower())
--+							place_of_supply = state_code_dict.get(normalize_state_key(state))
--+							if not place_of_supply:
--+								raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+							doc.place_of_supply = place_of_supply
-- 
-- 						doc.append("items", {
-- 							"item_code": item_code,
--@@ -1416,7 +1458,7 @@ class EcommerceBillImport(Document):
-- 										doc.append("taxes", {
-- 											"charge_type": "On Net Total",
-- 											"account_head": acc_head,
---											"rate": rate * 100,
--+											"rate": normalize_tax_rate(rate),
-- 											"tax_amount": amount,
-- 											"description": tax_type
-- 										})
--@@ -1501,7 +1543,7 @@ class EcommerceBillImport(Document):
-- 										pi_doc.append("taxes", {
-- 											"charge_type": "On Net Total",
-- 											"account_head": acc_head,
---											"rate": rate * 100,
--+											"rate": normalize_tax_rate(rate),
-- 											"tax_amount": amount,
-- 											"description": tax_type
-- 										})
--@@ -1652,9 +1694,10 @@ class EcommerceBillImport(Document):
-- 					si.update_stock = 1
-- 					if i.customers_billing_state:
-- 						state=i.customers_billing_state
---						if not state_code_dict.get(str(state.lower())):
---							raise Exception(f"State name Is Wrong Please Check")
---						si.place_of_supply=state_code_dict.get(str(state.lower()))
--+						place_of_supply = state_code_dict.get(normalize_state_key(state))
--+						if not place_of_supply:
--+							raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+						si.place_of_supply = place_of_supply
-- 					si.company_address = company_address
-- 					si.ecommerce_gstin = ecommerce_gstin
-- 					# if flt(i.cgst_amount)>0:
--@@ -1677,7 +1720,7 @@ class EcommerceBillImport(Document):
-- 							else:
-- 								si.append("taxes", {
-- 									"charge_type": "On Net Total",
---									"rate":rate,
--+									"rate": normalize_tax_rate(rate),
-- 									"account_head": acc_head,
-- 									"tax_amount": amount,
-- 									"description": tax_type
--@@ -1795,9 +1838,10 @@ class EcommerceBillImport(Document):
-- 				si.company_address = company_address
-- 				if i.customers_billing_state:
-- 					state=i.customers_billing_state
---					if not state_code_dict.get(str(state.lower())):
---						raise Exception(f"State name Is Wrong Please Check")
---					si.place_of_supply=state_code_dict.get(str(state.lower()))
--+					place_of_supply = state_code_dict.get(normalize_state_key(state))
--+					if not place_of_supply:
--+						raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+					si.place_of_supply = place_of_supply
-- 				si.ecommerce_gstin = ecommerce_gstin
-- 				si.location = location
-- 				si.is_return = 1
--@@ -1821,7 +1865,7 @@ class EcommerceBillImport(Document):
-- 							else:
-- 								si.append("taxes", {
-- 									"charge_type": "On Net Total",
---									"rate":rate,
--+									"rate": normalize_tax_rate(rate),
-- 									"account_head": acc_head,
-- 									"tax_amount": amount,
-- 									"description": tax_type
--@@ -1940,9 +1984,10 @@ class EcommerceBillImport(Document):
-- 				si.custom_inv_no = i.order_item_id
-- 				if i.destination_address_state:
-- 					state=i.destination_address_state
---					if not state_code_dict.get(str(state.lower())):
---						raise Exception(f"State name Is Wrong Please Check")
---					si.place_of_supply=state_code_dict.get(str(state.lower()))
--+					place_of_supply = state_code_dict.get(normalize_state_key(state))
--+					if not place_of_supply:
--+						raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+					si.place_of_supply = place_of_supply
-- 				si.taxes_and_charges = ""
-- 				si.custom_ecommerce_operator=self.ecommerce_mapping
-- 				si.custom_ecommerce_type=self.amazon_type
--@@ -2065,9 +2110,10 @@ class EcommerceBillImport(Document):
-- 				si.set_posting_time = 1
-- 				if i.customer_state:
-- 					state=i.customer_state
---					if not state_code_dict.get(str(state.lower())):
---						raise Exception(f"State name Is Wrong Please Check")
---					si.place_of_supply=state_code_dict.get(str(state.lower()))
--+					place_of_supply = state_code_dict.get(normalize_state_key(state))
--+					if not place_of_supply:
--+						raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+					si.place_of_supply = place_of_supply
-- 				# Parse the datetime and add 1 minute for returns
-- 				# refund_datetime = datetime.strptime(str(i.refund_date_time), '%Y-%m-%d %H:%M:%S') if isinstance(i.refund_date_time, str) else i.refund_date_time
-- 				# refund_datetime_plus_1min = refund_datetime + timedelta(minutes=1)
--@@ -2256,9 +2302,10 @@ class EcommerceBillImport(Document):
-- 					si.custom_ecommerce_type=self.amazon_type
-- 					if i.customers_billing_state:
-- 						state=i.customers_billing_state
---						if not state_code_dict.get(str(state.lower())):
---							raise Exception(f"State name Is Wrong Please Check")
---						si.place_of_supply=state_code_dict.get(str(state.lower()))
--+						place_of_supply = state_code_dict.get(normalize_state_key(state))
--+						if not place_of_supply:
--+							raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+						si.place_of_supply = place_of_supply
-- 					si.taxes_and_charges = ""
-- 					si.update_stock = 1
-- 					si.company_address = company_address
--@@ -2281,7 +2328,7 @@ class EcommerceBillImport(Document):
-- 							else:
-- 								si.append("taxes", {
-- 									"charge_type": "On Net Total",
---									"rate":rate,
--+									"rate": normalize_tax_rate(rate),
-- 									"account_head": acc_head,
-- 									"tax_amount": amount,
-- 									"description": tax_type
--@@ -2403,9 +2450,10 @@ class EcommerceBillImport(Document):
-- 				si.append("items", item_row)
-- 				if i.customers_billing_state:
-- 					state=i.customers_billing_state
---					if not state_code_dict.get(str(state.lower())):
---						raise Exception(f"State name Is Wrong Please Check")
---					si.place_of_supply=state_code_dict.get(str(state.lower()))
--+					place_of_supply = state_code_dict.get(normalize_state_key(state))
--+					if not place_of_supply:
--+						raise Exception(f"State name Is Wrong Please Check: {state!r}")
--+					si.place_of_supply = place_of_supply
-- 				for tax_type, rate,amount, acc_head in [
-- 						("CGST", i.cgst_rate,flt(i.cgst_amount), "Output Tax CGST - KGOPL"),
-- 						("SGST", i.sgst_rate_or_utgst_as_applicable,flt(i.sgst_amount_or_utgst_as_applicable), "Output Tax SGST - KGOPL"),
--@@ -2418,7 +2466,7 @@ class EcommerceBillImport(Document):
-- 							else:
-- 								si.append("taxes", {
-- 									"charge_type": "On Net Total",
---									"rate":rate,
--+									"rate": normalize_tax_rate(rate),
-- 									"account_head": acc_head,
-- 									"tax_amount": amount,
-- 									"description": tax_type
-diff --git a/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.js b/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.js
-index bf2c083..0cf1623 100644
---- a/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.js
-+++ b/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.js
-@@ -241,10 +241,33 @@ frappe.ui.form.on("Ecommerce Bill Import", {
- });
- 
- 
-+// Realtime progress (Data Import-like dashboard progress bar)
- frappe.realtime.on("data_import_progress", (data) => {
--    frappe.show_progress("Invoice Creation", data.progress, 100, data.message);
-+	const frm = cur_frm;
-+	if (!frm || frm.doctype !== "Ecommerce Bill Import") return;
- 
--    if (data.progress === 100) {
--        frappe.hide_progress();
-+	// Ignore progress meant for Frappe's "Data Import" doctype
-+	if (data?.data_import) return;
-+
-+	// If backend sends docname/doctype, respect it (prevents cross-doctype noise)
-+	if (data?.doctype && data.doctype !== frm.doctype) return;
-+	if (data?.docname && frm.doc?.name && data.docname !== frm.doc.name) return;
-+
-+	let percent = data?.progress;
-+	if (percent === undefined && data?.current && data?.total) {
-+		percent = Math.floor((data.current * 100) / data.total);
-+	}
-+	percent = Math.max(0, Math.min(100, percent || 0));
-+
-+	const message = data?.message || __("Processingâ€¦");
-+	frm.dashboard.show_progress(__("Import Progress"), percent, message);
-+	frm.page.set_indicator(__("In Progress"), "orange");
-+
-+	// Hide progress when complete
-+	if (percent >= 100) {
-+		setTimeout(() => {
-+			frm.dashboard.hide();
-+			frm.reload_doc();
-+		}, 1500);
-     }
- });
-\ No newline at end of file
-diff --git a/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py b/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
-index 698448f..6d15ad6 100644
---- a/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
-+++ b/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
-@@ -45,6 +45,101 @@ def normalize_warehouse_id(warehouse_id):
- 
-     return warehouse_id_str
- 
-+
-+def clean_csv_cell(val):
-+	"""Normalize a CSV cell to a safe string.
-+
-+	Why this exists:
-+	- E-commerce exports often contain long numeric IDs (order_item_id, shipment ids, etc.).
-+	- If pandas infers numeric types, those IDs can become scientific notation (e.g. 4.36e+17)
-+	  and lose precision. That later causes rows/items to be treated as duplicates and skipped.
-+
-+	Strategy:
-+	- Read CSV with dtype=str and disable NA parsing.
-+	- Then trim/strip quotes and normalize common "null-ish" strings.
-+	"""
-+	if val is None:
-+		return ""
-+
-+	s = str(val).strip()
-+	if not s:
-+		return ""
-+
-+	if s.lower() in {"nan", "none", "null"}:
-+		return ""
-+
-+	while (s.startswith('"') and s.endswith('"')) or (s.startswith("'") and s.endswith("'")):
-+		s = s[1:-1].strip()
-+
-+	# Convert integer-like floats (e.g. "123.0") to "123"
-+	if s.endswith(".0") and s[:-2].lstrip("-").isdigit():
-+		s = s[:-2]
-+
-+	return s
-+
-+
-+def resolve_ecommerce_gstin_from_mapping(ecommerce_mapping, seller_gstin):
-+	"""Resolve `Sales Invoice.ecommerce_gstin` from `Ecommerce Mapping.ecommerce_gstin_mapping`.
-+
-+	The `Ecommerce Mapping` doctype contains a child table `ecommerce_gstin_mapping` with fields:
-+	- `erp_company_gstin` (Link to `GSTIN`, autoname is `field:gstin`)
-+	- `ecommerce_operator_gstin` (E-commerce operator GSTIN)
-+
-+	Files from different platforms may provide either the seller/company GSTIN or the operator GSTIN.
-+	To keep imports deterministic, we support both lookup keys:
-+	- If `seller_gstin` matches `ecommerce_operator_gstin` -> return `ecommerce_operator_gstin`
-+	- If `seller_gstin` matches `erp_company_gstin` -> return `ecommerce_operator_gstin`
-+
-+	Args:
-+		ecommerce_mapping (Document): Ecommerce Mapping document (Amazon/Flipkart/Jiomart/Cred)
-+		seller_gstin (str): GSTIN value found in the import row
-+
-+	Returns:
-+		str | None: The Ecommerce Operator GSTIN to set on the Sales Invoice, else None.
-+	"""
-+	if not ecommerce_mapping:
-+		return None
-+
-+	gstin = (str(seller_gstin).strip().upper() if seller_gstin is not None else "")
-+	if not gstin:
-+		return None
-+
-+	for row in (getattr(ecommerce_mapping, "ecommerce_gstin_mapping", None) or []):
-+		operator_gstin_raw = row.ecommerce_operator_gstin or ""
-+		operator_gstin = operator_gstin_raw.strip().upper()
-+		company_gstin = (row.erp_company_gstin or "").strip().upper()
-+		if gstin == operator_gstin or gstin == company_gstin:
-+			if not operator_gstin:
-+				return None
-+
-+			# India Compliance validates `Sales Invoice.ecommerce_gstin` as a TCS (Tax Collector)
-+			# GSTIN. That means the 14th character must be "C" (see `india_compliance.gst_india.constants.TCS`).
-+			#
-+			# Validate here so the user gets a clear mapping-error pointing to the exact value.
-+			try:
-+				from india_compliance.gst_india.utils import validate_gstin as _validate_gstin
-+
-+				operator_gstin = _validate_gstin(
-+					operator_gstin, label="E-commerce GSTIN", is_tcs_gstin=True
-+				)
-+			except Exception:
-+				frappe.throw(
-+					_(
-+						"Invalid Ecommerce Operator (TCS) GSTIN in Ecommerce Mapping '{mapping}'. "
-+						"Mapped value: '{operator_gstin}'. Seller GSTIN from file: '{seller_gstin}'. "
-+						"Please update '{mapping}' -> Ecommerce GSTIN Mapping to a valid TCS GSTIN (14th character must be 'C')."
-+					).format(
-+						mapping=ecommerce_mapping.name,
-+						operator_gstin=operator_gstin_raw,
-+						seller_gstin=seller_gstin,
-+					),
-+					title=_("Invalid GSTIN Mapping"),
-+				)
-+
-+			return operator_gstin or None
-+
-+	return None
-+
- state_code_dict = {
-     "jammu and kashmir": "01-Jammu and Kashmir",
-     "jammu & kashmir": "01-Jammu and Kashmir",
-@@ -70,6 +165,7 @@ state_code_dict = {
-     "jharkhand": "20-Jharkhand",
-     "odisha": "21-Odisha",
-     "chhattisgarh": "22-Chhattisgarh",
-+    "chattisgarh": "22-Chhattisgarh",  # common misspelling seen in e-commerce exports
-     "madhya pradesh": "23-Madhya Pradesh",
-     "gujarat": "24-Gujarat",
- 
-@@ -103,6 +199,29 @@ class EcommerceBillImport(Document):
- 		if not self.ecommerce_mapping:
- 			frappe.throw(_("Please select an Ecommerce Mapping"))
- 
-+	def _publish_progress(self, *, current=None, total=None, progress=None, message="", phase=None):
-+		"""Publish realtime progress for long-running imports.
-+
-+		This intentionally mimics the UX pattern of Frappe's Data Import:
-+		- Backend publishes realtime events during background jobs (RQ worker)
-+		- Frontend listens and shows a dashboard progress bar
-+		"""
-+		payload = {
-+			"doctype": self.doctype,
-+			"docname": self.name,
-+			"message": message or "",
-+		}
-+		if current is not None:
-+			payload["current"] = int(current)
-+		if total is not None:
-+			payload["total"] = int(total) if int(total) else 0
-+		if progress is not None:
-+			payload["progress"] = int(progress)
-+		if phase:
-+			payload["phase"] = phase
-+
-+		frappe.publish_realtime("data_import_progress", payload, user=frappe.session.user)
-+
- 	def before_save(self):
- 		if self.get("__islocal"):
- 			if self.ecommerce_mapping=="Amazon":
-@@ -167,23 +286,21 @@ class EcommerceBillImport(Document):
- 	def show_preview(self):
- 		self.mtr_b2b=[]
- 		if self.mtr_b2b_attachment:
--			import numpy as np
--
-+			# Read CSV as strings to preserve long IDs exactly (avoid scientific notation)
- 			def clean(val):
--				if pd.isna(val):
--					return 0 if isinstance(val, (int, float, np.number)) else ""
--				try:
--					float_val = float(val)
--					return float_val
--				except (ValueError, TypeError):
--					return "" if pd.isna(val) else val
-+				return clean_csv_cell(val)
- 
- 			csv_file_url = self.mtr_b2b_attachment
- 			filename = csv_file_url.split('/files/')[-1]
- 			csv_file_path = get_file_path(filename)
- 
- 			try:
--				df = pd.read_csv(csv_file_path)
-+				df = pd.read_csv(
-+					csv_file_path,
-+					dtype=str,
-+					keep_default_na=False,
-+					na_filter=False,
-+				)
- 			except FileNotFoundError:
- 				frappe.throw(f"File not found: {csv_file_path}")
- 			except Exception as e:
-@@ -281,8 +398,8 @@ class EcommerceBillImport(Document):
- 				child_row.irn_filing_status = clean(row.get('Irn Filing Status'))
- 				child_row.irn_date = clean(row.get('Irn Date'))
- 				child_row.irn_error_code = clean(row.get('Irn Error Code'))
-+			# Sort by invoice date for stable grouping/processing downstream
- 			if self.mtr_b2b:
--					# Use getdate to handle ERPNext date parsing
- 					self.mtr_b2b.sort(
- 						key=lambda x: getdate(x.invoice_date) if x.invoice_date else frappe.utils.getdate("1900-01-01")
- 				)
-@@ -290,25 +407,22 @@ class EcommerceBillImport(Document):
- 	def append_mtr_b2c(self):
- 		self.mtr_b2c = []
- 		if self.mtr_b2c_attachment:
--			import numpy as np
--			import pandas as pd  # make sure pandas is imported if it's not already
- 			from frappe.utils.data import getdate
- 
- 			def clean(val):
--				if pd.isna(val):
--					return 0 if isinstance(val, (int, float, np.number)) else ""
--				try:
--					float_val = float(val)
--					return float_val
--				except (ValueError, TypeError):
--					return "" if pd.isna(val) else val
-+				return clean_csv_cell(val)
- 
- 			csv_file_url = self.mtr_b2c_attachment
- 			filename = csv_file_url.split('/files/')[-1]
- 			csv_file_path = get_file_path(filename)
- 
- 			try:
--				df = pd.read_csv(csv_file_path)
-+				df = pd.read_csv(
-+					csv_file_path,
-+					dtype=str,
-+					keep_default_na=False,
-+					na_filter=False,
-+				)
- 			except FileNotFoundError:
- 				frappe.throw(f"File not found: {csv_file_path}")
- 			except Exception as e:
-@@ -337,16 +451,8 @@ class EcommerceBillImport(Document):
- 	def append_stock_transfer_attachment(self):
- 		self.stock_transfer=[]
- 		if self.stock_transfer_attachment:
--			import numpy as np
--
- 			def clean(val):
--				if pd.isna(val):
--					return 0 if isinstance(val, (int, float, np.number)) else ""
--				try:
--					float_val = float(val)
--					return float_val
--				except (ValueError, TypeError):
--					return "" if pd.isna(val) else val
-+				return clean_csv_cell(val)
- 
- 			
- 			csv_file_url = self.stock_transfer_attachment
-@@ -354,7 +460,12 @@ class EcommerceBillImport(Document):
- 			csv_file_path = get_file_path(filename)
- 
- 			try:
--				df = pd.read_csv(csv_file_path)
-+				df = pd.read_csv(
-+					csv_file_path,
-+					dtype=str,
-+					keep_default_na=False,
-+					na_filter=False,
-+				)
- 			except FileNotFoundError:
- 				frappe.throw(f"File not found: {csv_file_path}")
- 			except Exception as e:
-@@ -370,7 +481,6 @@ class EcommerceBillImport(Document):
- 					# If the field exists on the child table, set it
- 					if fieldname in [d.fieldname for d in frappe.get_meta('Amazon Stock Transfer').fields]:
- 						child_row.set(fieldname, clean(value))
--						print("fieldname5667e787e8e89",value)
- 					child_row.set("hsnsac", clean(clean(row.get('Hsn/sac'))))
- 
- 			if self.stock_transfer:
-@@ -411,15 +521,10 @@ class EcommerceBillImport(Document):
- 				except Exception:
- 					return str(val)
- 
--
--			print(f"Attachment URL: {self.cred_attach}")
--
- 			xl_file_url = self.cred_attach
- 			filename = xl_file_url.split('/files/')[-1]
--			print(f"Filename extracted: {filename}")
- 
- 			xl_file_path = get_file_path(filename)
--			print(f"File path: {xl_file_path}")
- 
- 			if not os.path.exists(xl_file_path):
- 				frappe.throw(f"File not found at path: {xl_file_path}")
-@@ -469,8 +574,7 @@ class EcommerceBillImport(Document):
- 
- 				if mapped_count > 0:
- 					success_count += 1
--
--			print(f"Total rows successfully mapped: {success_count}")
-+			# Mapping summary intentionally not printed to stdout (keeps background worker logs clean)
- 
- 	def append_flipkart(self):
- 		import pandas as pd
-@@ -478,12 +582,24 @@ class EcommerceBillImport(Document):
- 		from frappe.utils.file_manager import get_file_path
- 
- 		def clean(val):
--			"""Cleans cell value by removing spaces and surrounding quotes."""
--			if pd.isna(val):
-+			"""Normalize CSV cell values.
-+
-+			Important: Flipkart exports contain long numeric IDs (e.g. Order Item ID).
-+			If pandas infers numeric types, those IDs can turn into scientific notation
-+			(e.g. 4.36e+17) and lose precision, which later causes invoices to be skipped.
-+			"""
-+			if val is None:
- 				return ""
- 			val = str(val).strip()
-+			if not val:
-+				return ""
-+			if val.lower() in {"nan", "none", "null"}:
-+				return ""
- 			while (val.startswith('"') and val.endswith('"')) or (val.startswith("'") and val.endswith("'")):
- 				val = val[1:-1].strip()
-+			# Convert integer-like floats (e.g. "123.0") to "123"
-+			if val.endswith(".0") and val[:-2].lstrip("-").isdigit():
-+				val = val[:-2]
- 			return val
- 
- 		# Check if file attached
-@@ -499,7 +615,13 @@ class EcommerceBillImport(Document):
- 
- 		# Load CSV
- 		try:
--			df = pd.read_csv(file_path)
-+			# Read everything as string to preserve long IDs exactly (avoid scientific notation)
-+			df = pd.read_csv(
-+				file_path,
-+				dtype=str,
-+				keep_default_na=False,
-+				na_filter=False,
-+			)
- 		except Exception as e:
- 			frappe.throw(f"Failed to read CSV file: {str(e)}")
- 
-@@ -538,25 +660,22 @@ class EcommerceBillImport(Document):
- 	def append_jio_mart(self):
- 		self.jio_mart_items = []
- 		if self.jio_mart_attach:
--			import numpy as np
--			import pandas as pd  # make sure pandas is imported if it's not already
- 			from frappe.utils.data import getdate
- 
- 			def clean(val):
--				if pd.isna(val):
--					return 0 if isinstance(val, (int, float, np.number)) else ""
--				try:
--					float_val = float(val)
--					return float_val
--				except (ValueError, TypeError):
--					return "" if pd.isna(val) else val
-+				return clean_csv_cell(val)
- 
- 			csv_file_url = self.jio_mart_attach
- 			filename = csv_file_url.split('/files/')[-1]
- 			csv_file_path = get_file_path(filename)
- 
- 			try:
--				df = pd.read_csv(csv_file_path)
-+				df = pd.read_csv(
-+					csv_file_path,
-+					dtype=str,
-+					keep_default_na=False,
-+					na_filter=False,
-+				)
- 			except FileNotFoundError:
- 				frappe.throw(f"File not found: {csv_file_path}")
- 			except Exception as e:
-@@ -605,18 +724,22 @@ class EcommerceBillImport(Document):
- 
- 		# Group rows by Invoice
- 		for idx, child_row in enumerate(self.mtr_b2b, 1):
--			invoice_no = child_row.invoice_number
--			if invoice_no not in invoice_groups:
--				invoice_groups[invoice_no] = []
--			invoice_groups[invoice_no].append((idx, child_row))
-+			# Cancelled rows often have an empty invoice number; skip them to avoid errors
-+			invoice_no = (child_row.invoice_number or "").strip()
-+			if not invoice_no:
-+				continue
-+
-+			invoice_groups.setdefault(invoice_no, []).append((idx, child_row))
- 
- 		total_invoices = len(invoice_groups) or 1  # avoid div-by-zero
- 
- 		# ðŸ”¹ Initial realtime update
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 0, "message": f"Starting Amazon B2B import (0/{total_invoices})"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			current=0,
-+			total=total_invoices,
-+			progress=0,
-+			message=f"Starting Amazon B2B import (0/{total_invoices})",
-+			phase="amazon_mtr_b2b",
- 		)
- 
- 		# Process each invoice group
-@@ -672,23 +795,23 @@ class EcommerceBillImport(Document):
- 				amazon = frappe.get_doc("Ecommerce Mapping", {"platform": "Amazon"})
- 				error_log=[]
- 				warehouse_mapping_missing = False
-+				# If the sales invoice is already submitted, don't recreate it. Refunds (credit notes)
-+				# are handled below independently.
-+				if shipment_items and existing_si:
-+					shipment_items = []
- 				
- 				if shipment_items:
--					exists_in_item = frappe.db.sql("""
--						SELECT sii.name FROM `tabSales Invoice Item` sii
--						JOIN `tabSales Invoice` si ON sii.parent = si.name
--						WHERE sii.custom_ecom_item_id = %s AND si.docstatus != 1 AND si.is_return = 0
--						""", items_data[0][1].get("shipment_item_id"))
--					if exists_in_item:
--						# ðŸ”¹ Per-invoice group progress update before continue
--						percent = int((count / total_invoices) * 100)
--						frappe.publish_realtime(
--							"data_import_progress",
--							{"progress": percent, "message": f"Processed {count}/{total_invoices} invoices"},
--							user=frappe.session.user
--						)
--						continue
- 					try:
-+						# Ecommerce GSTIN is mandatory. Resolve it once per invoice group from mapping table.
-+						mapped_ecommerce_gstin = resolve_ecommerce_gstin_from_mapping(
-+							amazon, shipment_items[0][1].seller_gstin
-+						)
-+						if not mapped_ecommerce_gstin:
-+							raise Exception(
-+								f"Ecommerce GSTIN mapping missing for Seller GSTIN: {shipment_items[0][1].seller_gstin} "
-+								f"(Invoice No: {invoice_no}). Please add it in Ecommerce Mapping '{amazon.name}' -> Ecommerce GSTIN Mapping."
-+							)
-+
- 						if existing_si_draft:
- 							si = frappe.get_doc("Sales Invoice", existing_si_draft)
- 						else:
-@@ -702,38 +825,52 @@ class EcommerceBillImport(Document):
- 							si.posting_time = get_time(items_data[0][1].get("invoice_date"))
- 							si.custom_inv_no = invoice_no
- 							si.custom_ecommerce_invoice_id=invoice_no
--							si.__newname=invoice_no
-+							# Avoid duplicate primary key errors if an invoice with this name already exists
-+							existing_by_name = frappe.db.exists("Sales Invoice", invoice_no)
-+							if not existing_by_name:
-+								si.__newname = invoice_no
- 							si.custom_ecommerce_operator=self.ecommerce_mapping
- 							si.custom_ecommerce_type=self.amazon_type
- 							si.taxes = []
- 							si.update_stock = 1
-+
-+						# Always set ecommerce_gstin from mapping (required for GST reporting)
-+						si.ecommerce_gstin = mapped_ecommerce_gstin
-+
-+						# De-duplicate within this invoice (do NOT skip across other invoices)
-+						existing_item_ids = {
-+							d.get("custom_ecom_item_id")
-+							for d in (si.get("items") or [])
-+							if d.get("custom_ecom_item_id")
-+						}
- 						items_append=[]
- 						for idx, child_row in shipment_items:
- 							try:
-+								shipment_item_id = child_row.shipment_item_id
-+								if shipment_item_id and shipment_item_id in existing_item_ids:
-+									continue
-+
- 								itemcode = next((i.erp_item for i in amazon.ecom_item_table if i.ecom_item_id == child_row.get(amazon.ecom_sku_column_header)), None)
- 								if not itemcode:
- 									error_names.append(invoice_no)
- 									raise Exception(f"Item mapping not found for SKU: {child_row.get(amazon.ecom_sku_column_header)}")
- 								warehouse, location, com_address = None, None, None
-+								warehouse_id = normalize_warehouse_id(child_row.warehouse_id)
- 								for wh_map in amazon.ecommerce_warehouse_mapping:
--									print("##############################2345",child_row.warehouse_id)
--									if wh_map.ecom_warehouse_id == child_row.warehouse_id:
-+									if wh_map.ecom_warehouse_id == warehouse_id:
- 										warehouse = wh_map.erp_warehouse
- 										location = wh_map.location
- 										com_address = wh_map.erp_address
- 										break
--								print("##########################",child_row.warehouse_id,warehouse)
- 								if not warehouse:
--									print("##############################AJ",warehouse)
--									warehouse_mapping_missing = True
--									error_names.append(invoice_no)
--									raise Exception(f"Warehouse Mapping not found for Warehouse Id: {child_row.warehouse_id}")
--
--								ecommerce_gstin = None
--								for gstin in amazon.ecommerce_gstin_mapping:
--									if gstin.ecommerce_operator_gstin == child_row.seller_gstin:
--										# ecommerce_gstin = gstin.ecommerce_operator_gstin
--										break
-+									if not warehouse_id:
-+										warehouse = amazon.default_company_warehouse
-+										location = amazon.default_company_location
-+										com_address = amazon.default_company_address
-+									else:
-+										warehouse_mapping_missing = True
-+										error_names.append(invoice_no)
-+										raise Exception(f"Warehouse Mapping not found for Warehouse Id: {warehouse_id}")
- 
- 								if location:
- 									si.location = location
-@@ -741,7 +878,7 @@ class EcommerceBillImport(Document):
- 									si.set_warehouse = warehouse
- 
- 								si.company_address = com_address
--								si.ecommerce_gstin = ecommerce_gstin
-+								si.ecommerce_gstin = mapped_ecommerce_gstin
- 								hsn_code=frappe.db.get_value("Item",itemcode,"gst_hsn_code")
- 								if status!="Active":
- 									if child_row.ship_to_state:
-@@ -762,8 +899,11 @@ class EcommerceBillImport(Document):
- 									"margin_type": "Amount" if flt(child_row.item_promo_discount) > 0 else None,
- 									"margin_rate_or_amount": flt(child_row.item_promo_discount),
- 									"income_account": amazon.income_account,
--									"is_free_item": 1 if str(child_row.transaction_type) == "FreeReplacement" else 0
-+									"is_free_item": 1 if str(child_row.transaction_type) == "FreeReplacement" else 0,
-+									"custom_ecom_item_id": shipment_item_id,
- 								})
-+								if shipment_item_id:
-+									existing_item_ids.add(shipment_item_id)
- 								items_append.append(itemcode)
- 								for tax_type,rate, amount, acc_head in [
- 									("CGST", flt(child_row.cgst_rate),flt(child_row.cgst_tax), "Output Tax CGST - KGOPL"),
-@@ -818,20 +958,6 @@ class EcommerceBillImport(Document):
- 
- 				si_return_error=[]
- 				if refund_items and not warehouse_mapping_missing:
--					exists_in_item = frappe.db.sql("""
--						SELECT sii.name FROM `tabSales Invoice Item` sii
--						JOIN `tabSales Invoice` si ON sii.parent = si.name
--						WHERE sii.custom_ecom_item_id = %s AND si.docstatus != 1 AND si.is_return = 1
--						""", child_row.shipment_item_id)
--					if exists_in_item:
--						# ðŸ”¹ Per-invoice group progress update before continue
--						percent = int((count / total_invoices) * 100)
--						frappe.publish_realtime(
--							"data_import_progress",
--							{"progress": percent, "message": f"Processed {count}/{total_invoices} invoices"},
--							user=frappe.session.user
--						)
--						continue
- 					try:
- 						# if not existing_si:
- 						# 	si_return_error.append(invoice_no)
-@@ -841,44 +967,112 @@ class EcommerceBillImport(Document):
- 						# 		"message": f"Refund requested but original submitted invoice not found for {invoice_no}."
- 						# 	})
- 
--						si_return = frappe.new_doc("Sales Invoice")
--						si_return.is_return = 1
--						si_return.custom_ecommerce_operator=self.ecommerce_mapping
--						si_return.custom_ecommerce_type=self.amazon_type
--						si_return.customer = customer
--						si_return.set_posting_time=1
--						# Parse the datetime and add 1 minute for returns
--						si_return.posting_date = getdate(refund_items[0][1].get("credit_note_date"))
--						si_return.posting_time = get_time(refund_items[0][1].get("credit_note_date"))
--						si_return.custom_ecommerce_invoice_id=refund_items[0][1].get("credit_note_no")
--						si_return.__newname = refund_items[0][1].get("credit_note_no")
--						si_return.custom_inv_no = invoice_no
--						si_return.update_stock = 1
-+						credit_note_no = refund_items[0][1].get("credit_note_no")
-+						if not credit_note_no:
-+							si_return_error.append(invoice_no)
-+							errors.append({
-+								"idx": refund_items[0][0],
-+								"invoice_id": invoice_no,
-+								"message": "Missing Credit Note No for refund row(s)"
-+							})
-+							raise Exception("Missing Credit Note No")
-+
-+						# Skip if this credit note return invoice already exists (idempotent re-runs)
-+						existing_return = frappe.db.get_value(
-+							"Sales Invoice",
-+							{"custom_ecommerce_invoice_id": credit_note_no, "is_return": 1, "docstatus": 1},
-+							"name",
-+						)
-+						if existing_return:
-+							# Return invoice already created for this credit note; treat as processed
-+							percent = int((count / total_invoices) * 100) if total_invoices else 100
-+							self._publish_progress(
-+								current=count,
-+								total=total_invoices,
-+								progress=percent,
-+								message=f"Processed {count}/{total_invoices} invoices",
-+								phase="amazon_mtr_b2b",
-+							)
-+							frappe.db.commit()
-+							continue
-+
-+						# Ecommerce GSTIN is mandatory for returns too
-+						mapped_ecommerce_gstin = resolve_ecommerce_gstin_from_mapping(
-+							amazon, refund_items[0][1].seller_gstin
-+						)
-+						if not mapped_ecommerce_gstin:
-+							raise Exception(
-+								f"Ecommerce GSTIN mapping missing for Seller GSTIN: {refund_items[0][1].seller_gstin} "
-+								f"(Credit Note No: {credit_note_no}, Invoice No: {invoice_no}). "
-+								f"Please add it in Ecommerce Mapping '{amazon.name}' -> Ecommerce GSTIN Mapping."
-+							)
-+
-+						draft_return = frappe.db.get_value(
-+							"Sales Invoice",
-+							{"custom_ecommerce_invoice_id": credit_note_no, "is_return": 1, "docstatus": 0},
-+							"name",
-+						)
-+
-+						if draft_return:
-+							si_return = frappe.get_doc("Sales Invoice", draft_return)
-+							si_return.is_return = 1
-+						else:
-+							si_return = frappe.new_doc("Sales Invoice")
-+							si_return.is_return = 1
-+							si_return.custom_ecommerce_operator = self.ecommerce_mapping
-+							si_return.custom_ecommerce_type = self.amazon_type
-+							si_return.customer = customer
-+							si_return.set_posting_time = 1
-+							# Parse the datetime and add 1 minute for returns
-+							si_return.posting_date = getdate(refund_items[0][1].get("credit_note_date"))
-+							si_return.posting_time = get_time(refund_items[0][1].get("credit_note_date"))
-+							si_return.custom_ecommerce_invoice_id = credit_note_no
-+							# Avoid duplicate primary key errors if an invoice with this name already exists
-+							existing_by_name = frappe.db.exists("Sales Invoice", credit_note_no)
-+							if not existing_by_name:
-+								si_return.__newname = credit_note_no
-+							si_return.custom_inv_no = invoice_no
-+							si_return.taxes = []
-+							si_return.update_stock = 1
-+
-+						# Always set ecommerce_gstin from mapping (required for GST reporting)
-+						si_return.ecommerce_gstin = mapped_ecommerce_gstin
-+
-+						# De-duplicate within this return invoice only
-+						existing_return_item_ids = {
-+							d.get("custom_ecom_item_id")
-+							for d in (si_return.get("items") or [])
-+							if d.get("custom_ecom_item_id")
-+						}
- 						items_append=[]
- 						for idx, child_row in refund_items:
- 							try:
-+								shipment_item_id = child_row.shipment_item_id
-+								if shipment_item_id and shipment_item_id in existing_return_item_ids:
-+									continue
-+
- 								itemcode = next((i.erp_item for i in amazon.ecom_item_table if i.ecom_item_id == child_row.get(amazon.ecom_sku_column_header)), None)
- 								if not itemcode:
- 									error_names.append(invoice_no)
- 									raise Exception(f"Item mapping not found for SKU: {child_row.get(amazon.ecom_sku_column_header)}")
- 								warehouse, location, com_address = None, None, None
-+								warehouse_id = normalize_warehouse_id(child_row.warehouse_id)
- 								for wh_map in amazon.ecommerce_warehouse_mapping:
--									if wh_map.ecom_warehouse_id == child_row.warehouse_id:
-+									if wh_map.ecom_warehouse_id == warehouse_id:
- 										warehouse = wh_map.erp_warehouse
- 										location = wh_map.location
- 										com_address = wh_map.erp_address
- 										break
- 
- 								if not warehouse:
--									warehouse_mapping_missing = True
--									error_names.append(invoice_no)
--									raise Exception(f"Warehouse Mapping not found for Warehouse Id: {child_row.warehouse_id}")
--
--								ecommerce_gstin = None
--								for gstin in amazon.ecommerce_gstin_mapping:
--									if gstin.ecommerce_operator_gstin == child_row.seller_gstin:
--										# ecommerce_gstin = gstin.ecommerce_operator_gstin
--										break
-+									if not warehouse_id:
-+										warehouse = amazon.default_company_warehouse
-+										location = amazon.default_company_location
-+										com_address = amazon.default_company_address
-+									else:
-+										warehouse_mapping_missing = True
-+										error_names.append(invoice_no)
-+										raise Exception(f"Warehouse Mapping not found for Warehouse Id: {warehouse_id}")
- 								if status!="Active":
- 									if child_row.ship_to_state:
- 										state=child_row.ship_to_state
-@@ -893,7 +1087,7 @@ class EcommerceBillImport(Document):
- 									si_return.set_warehouse = warehouse
- 
- 								si_return.company_address = com_address
--								si_return.ecommerce_gstin = ecommerce_gstin
-+								si_return.ecommerce_gstin = mapped_ecommerce_gstin
- 								hsn_code=frappe.db.get_value("Item",itemcode,"gst_hsn_code")
- 
- 								si_return.append("items", {
-@@ -907,7 +1101,10 @@ class EcommerceBillImport(Document):
- 									"margin_type": "Amount" if flt(child_row.item_promo_discount) > 0 else None,
- 									"margin_rate_or_amount": flt(child_row.item_promo_discount),
- 									"income_account": amazon.income_account,
-+									"custom_ecom_item_id": shipment_item_id,
- 								})
-+								if shipment_item_id:
-+									existing_return_item_ids.add(shipment_item_id)
- 								for tax_type,rate, amount, acc_head in [
- 									("CGST", flt(child_row.cgst_rate),flt(child_row.cgst_tax), "Output Tax CGST - KGOPL"),
- 									("SGST",flt(child_row.sgst_rate)+flt(child_row.utgst_rate), flt(child_row.sgst_tax)+flt(child_row.utgst_tax), "Output Tax SGST - KGOPL"),
-@@ -962,10 +1159,12 @@ class EcommerceBillImport(Document):
- 
- 			# ðŸ”¹ Realtime progress update after each invoice group
- 			percent = int((count / total_invoices) * 100)
--			frappe.publish_realtime(
--				"data_import_progress",
--				{"progress": percent, "message": f"Processed {count}/{total_invoices} invoices"},
--				user=frappe.session.user
-+			self._publish_progress(
-+				current=count,
-+				total=total_invoices,
-+				progress=percent,
-+				message=f"Processed {count}/{total_invoices} invoices",
-+				phase="amazon_mtr_b2b",
- 			)
- 			# Commit after each invoice to reduce memory load
- 			frappe.db.commit()
-@@ -984,10 +1183,12 @@ class EcommerceBillImport(Document):
- 		self.save()
- 
- 		# ðŸ”¹ Final realtime update
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 100, "message": "Amazon B2B Import Completed âœ…"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			current=total_invoices,
-+			total=total_invoices,
-+			progress=100,
-+			message="Amazon B2B Import Completed âœ…",
-+			phase="amazon_mtr_b2b",
- 		)
- 
- 		return success_count
-@@ -1008,12 +1209,24 @@ class EcommerceBillImport(Document):
- 
- 		# -------- Group Rows by Invoice --------
- 		for idx, child_row in enumerate(self.mtr_b2c, 1):
--			invoice_no = child_row.invoice_number
--			if invoice_no not in invoice_groups:
--				invoice_groups[invoice_no] = []
--			invoice_groups[invoice_no].append((idx, child_row))
-+			# Cancelled rows often have an empty invoice number; skip them to avoid errors
-+			invoice_no = (child_row.invoice_number or "").strip()
-+			if not invoice_no:
-+				continue
- 
--		total_invoices = len(invoice_groups)
-+			invoice_groups.setdefault(invoice_no, []).append((idx, child_row))
-+
-+		expected_invoices = len(invoice_groups)
-+		total_invoices = expected_invoices or 1  # avoid div-by-zero for progress
-+
-+		# ðŸ”¹ Initial progress update (Data Import-style dashboard progress)
-+		self._publish_progress(
-+			current=0,
-+			total=expected_invoices or 1,
-+			progress=0,
-+			message=f"Starting Amazon B2C import (0/{expected_invoices})" if expected_invoices else "Starting Amazon B2C import",
-+			phase="amazon_mtr_b2c",
-+		)
- 
- 		# -------- Process Each Invoice Group --------
- 		for count, (invoice_no, items_data) in enumerate(invoice_groups.items(), start=1):
-@@ -1025,9 +1238,23 @@ class EcommerceBillImport(Document):
- 				existing_si = frappe.db.get_value("Sales Invoice", {"custom_inv_no": invoice_no, "docstatus": 1}, "name")
- 				amazon = frappe.get_doc("Ecommerce Mapping", {"platform": "Amazon"})
- 				warehouse_mapping_missing = False
-+				# If the sales invoice is already submitted, don't recreate it. Refunds (credit notes)
-+				# are handled below independently.
-+				if shipment_items and existing_si:
-+					shipment_items = []
- 
- 				# -------- Shipment Items --------
- 				if shipment_items:
-+					# Ecommerce GSTIN is mandatory. Resolve it once per invoice group from mapping table.
-+					mapped_ecommerce_gstin = resolve_ecommerce_gstin_from_mapping(
-+						amazon, shipment_items[0][1].seller_gstin
-+					)
-+					if not mapped_ecommerce_gstin:
-+						raise Exception(
-+							f"Ecommerce GSTIN mapping missing for Seller GSTIN: {shipment_items[0][1].seller_gstin} "
-+							f"(Invoice No: {invoice_no}). Please add it in Ecommerce Mapping '{amazon.name}' -> Ecommerce GSTIN Mapping."
-+						)
-+
- 					if existing_si_draft:
- 						si = frappe.get_doc("Sales Invoice", existing_si_draft)
- 					else:
-@@ -1041,21 +1268,30 @@ class EcommerceBillImport(Document):
- 						si.posting_time = get_time(items_data[0][1].get("invoice_date"))
- 						si.custom_inv_no = invoice_no
- 						si.custom_ecommerce_invoice_id = invoice_no
--						si.__newname = invoice_no
-+						# Avoid duplicate primary key errors if an invoice with this name already exists
-+						existing_by_name = frappe.db.exists("Sales Invoice", invoice_no)
-+						if not existing_by_name:
-+							si.__newname = invoice_no
- 						si.custom_ecommerce_operator = self.ecommerce_mapping
- 						si.custom_ecommerce_type = self.amazon_type
- 						si.taxes_and_charges = ""
- 						si.update_stock = 1
- 
-+					# Always set ecommerce_gstin from mapping (required for GST reporting)
-+					si.ecommerce_gstin = mapped_ecommerce_gstin
-+
-+					# De-duplicate within this invoice (do NOT skip across other invoices)
-+					existing_item_ids = {
-+						d.get("custom_ecom_item_id")
-+						for d in (si.get("items") or [])
-+						if d.get("custom_ecom_item_id")
-+					}
-+
- 					items_append = []
- 					for idx, child_row in shipment_items:
- 						try:
--							exists_in_item = frappe.db.sql("""
--								SELECT sii.name FROM `tabSales Invoice Item` sii
--								JOIN `tabSales Invoice` si ON sii.parent = si.name
--								WHERE sii.custom_ecom_item_id = %s AND si.docstatus != 1 AND si.is_return = 0
--							""", child_row.shipment_item_id)
--							if exists_in_item:
-+							shipment_item_id = child_row.shipment_item_id
-+							if shipment_item_id and shipment_item_id in existing_item_ids:
- 								continue
- 
- 							itemcode = next(
-@@ -1084,12 +1320,6 @@ class EcommerceBillImport(Document):
- 									warehouse_mapping_missing = True
- 									raise Exception(f"Warehouse Mapping not found for Warehouse Id: {warehouse_id}")
- 
--							# ---- GSTIN Mapping ----
--							ecommerce_gstin = None
--							for gstin in amazon.ecommerce_gstin_mapping:
--								if gstin.ecommerce_operator_gstin == child_row.seller_gstin:
--									ecommerce_gstin = gstin.ecommerce_operator_gstin
--
- 							if not si.location:
- 								si.location = location
- 							if not si.set_warehouse:
-@@ -1101,7 +1331,7 @@ class EcommerceBillImport(Document):
- 									error_names.append(invoice_no)
- 									raise Exception(f"State name Is Wrong Please Check")
- 								si.place_of_supply = state_code_dict.get(str(state.lower()))
--							si.ecommerce_gstin = ecommerce_gstin
-+							si.ecommerce_gstin = mapped_ecommerce_gstin
- 
- 							# ---- Append Item ----
- 							hsn_code = frappe.db.get_value("Item", itemcode, "gst_hsn_code")
-@@ -1116,8 +1346,11 @@ class EcommerceBillImport(Document):
- 								"margin_type": "Amount" if flt(child_row.item_promo_discount) > 0 else None,
- 								"margin_rate_or_amount": flt(child_row.item_promo_discount),
- 								"income_account": amazon.income_account,
--								"is_free_item": 1 if str(child_row.transaction_type) == "FreeReplacement" else 0
-+								"is_free_item": 1 if str(child_row.transaction_type) == "FreeReplacement" else 0,
-+								"custom_ecom_item_id": shipment_item_id,
- 							})
-+							if shipment_item_id:
-+								existing_item_ids.add(shipment_item_id)
- 							items_append.append(itemcode)
- 
- 							# ---- Taxes ----
-@@ -1193,35 +1426,89 @@ class EcommerceBillImport(Document):
- 					# 		"message": f"Refund requested but original submitted invoice not found for {invoice_no}."
- 					# 	})
- 					# 	continue
--					ritems_append = []
--					si_return = frappe.new_doc("Sales Invoice")
--					si_return.is_return = 1
--					si_return.customer = val
--					si_return.set_posting_time=1
--
--					# Parse the datetime and add 1 minute for returns
--					si_return.posting_date = getdate(refund_items[0][1].get("credit_note_date"))
--					si_return.posting_time = get_time(refund_items[0][1].get("credit_note_date"))
--					si_return.custom_ecommerce_operator = self.ecommerce_mapping
--					si_return.custom_ecommerce_type = self.amazon_type
--					si_return.custom_inv_no = invoice_no
--					si_return.custom_ecommerce_invoice_id = refund_items[0][1].get("credit_note_no")
--					si_return.__newname = refund_items[0][1].get("credit_note_no")
--					si_return.taxes = []
--					si_return.update_stock = 1
--					print("#################(489595099505050)",refund_items[0][1].get("credit_note_no"))
-+					credit_note_no = refund_items[0][1].get("credit_note_no")
-+					if not credit_note_no:
-+						errors.append({
-+							"idx": refund_items[0][0],
-+							"invoice_id": invoice_no,
-+							"message": "Missing Credit Note No for refund row(s)"
-+						})
-+						continue
-+
-+					# Skip if this credit note return invoice already exists (idempotent re-runs)
-+					existing_return = frappe.db.get_value(
-+						"Sales Invoice",
-+						{"custom_ecommerce_invoice_id": credit_note_no, "is_return": 1, "docstatus": 1},
-+						"name",
-+					)
-+					if existing_return:
-+						# Return invoice already created for this credit note; treat as processed
-+						percent = int((count / total_invoices) * 100) if total_invoices else 100
-+						self._publish_progress(
-+							current=count,
-+							total=total_invoices,
-+							progress=percent,
-+							message=f"Processed {count}/{total_invoices} invoices",
-+							phase="amazon_mtr_b2c",
-+						)
-+						frappe.db.commit()
-+						continue
-+
-+					# Ecommerce GSTIN is mandatory for returns too
-+					mapped_ecommerce_gstin = resolve_ecommerce_gstin_from_mapping(
-+						amazon, refund_items[0][1].seller_gstin
-+					)
-+					if not mapped_ecommerce_gstin:
-+						raise Exception(
-+							f"Ecommerce GSTIN mapping missing for Seller GSTIN: {refund_items[0][1].seller_gstin} "
-+							f"(Credit Note No: {credit_note_no}, Invoice No: {invoice_no}). "
-+							f"Please add it in Ecommerce Mapping '{amazon.name}' -> Ecommerce GSTIN Mapping."
-+						)
-+
-+					draft_return = frappe.db.get_value(
-+						"Sales Invoice",
-+						{"custom_ecommerce_invoice_id": credit_note_no, "is_return": 1, "docstatus": 0},
-+						"name",
-+					)
- 
-+					ritems_append = []
- 					si_error = []
-+					if draft_return:
-+						si_return = frappe.get_doc("Sales Invoice", draft_return)
-+						si_return.is_return = 1
-+					else:
-+						si_return = frappe.new_doc("Sales Invoice")
-+						si_return.is_return = 1
-+						si_return.customer = val
-+						si_return.set_posting_time = 1
-+
-+						# Parse the datetime and add 1 minute for returns
-+						si_return.posting_date = getdate(refund_items[0][1].get("credit_note_date"))
-+						si_return.posting_time = get_time(refund_items[0][1].get("credit_note_date"))
-+						si_return.custom_ecommerce_operator = self.ecommerce_mapping
-+						si_return.custom_ecommerce_type = self.amazon_type
-+						si_return.custom_inv_no = invoice_no
-+						si_return.custom_ecommerce_invoice_id = credit_note_no
-+						# Avoid duplicate primary key errors if an invoice with this name already exists
-+						existing_by_name = frappe.db.exists("Sales Invoice", credit_note_no)
-+						if not existing_by_name:
-+							si_return.__newname = credit_note_no
-+						si_return.taxes = []
-+						si_return.update_stock = 1
-+
-+					# Always set ecommerce_gstin from mapping (required for GST reporting)
-+					si_return.ecommerce_gstin = mapped_ecommerce_gstin
-+
-+					# De-duplicate within this return invoice only
-+					existing_return_item_ids = {
-+						d.get("custom_ecom_item_id")
-+						for d in (si_return.get("items") or [])
-+						if d.get("custom_ecom_item_id")
-+					}
- 					for idx, child_row in refund_items:
- 						try:
--							print("@@@@@@@@@@@@@@@@@@@@@@@@@@@",child_row.credit_note_no)
--							
--							exists_in_item = frappe.db.sql("""
--								SELECT sii.name FROM `tabSales Invoice Item` sii
--								JOIN `tabSales Invoice` si ON sii.parent = si.name
--								WHERE sii.custom_ecom_item_id = %s AND si.docstatus != 1 AND si.is_return = 1
--							""", child_row.shipment_item_id)
--							if exists_in_item:
-+							shipment_item_id = child_row.shipment_item_id
-+							if shipment_item_id and shipment_item_id in existing_return_item_ids:
- 								continue
- 
- 							itemcode = next(
-@@ -1249,11 +1536,6 @@ class EcommerceBillImport(Document):
- 									warehouse_mapping_missing = True
- 									raise Exception(f"Warehouse Mapping not found for Warehouse Id: {warehouse_id}")
- 
--							ecommerce_gstin = None
--							for gstin in amazon.ecommerce_gstin_mapping:
--								if gstin.ecommerce_operator_gstin == child_row.seller_gstin:
--									ecommerce_gstin = gstin.ecommerce_operator_gstin
--
- 							if not si_return.location:
- 								si_return.location = location
- 							if not si_return.set_warehouse:
-@@ -1265,7 +1547,7 @@ class EcommerceBillImport(Document):
- 									si_error.append(invoice_no)
- 									raise Exception(f"State name Is Wrong Please Check")
- 								si_return.place_of_supply = state_code_dict.get(str(state.lower()))
--							si_return.ecommerce_gstin = ecommerce_gstin
-+							si_return.ecommerce_gstin = mapped_ecommerce_gstin
- 
- 							hsn_code = frappe.db.get_value("Item", itemcode, "gst_hsn_code")
- 							si_return.append("items", {
-@@ -1279,8 +1561,10 @@ class EcommerceBillImport(Document):
- 								"tax_rate": flt(child_row.total_tax_amount),
- 								"margin_type": "Amount" if flt(child_row.item_promo_discount) > 0 else None,
- 								"margin_rate_or_amount": flt(child_row.item_promo_discount),
--								"custom_ecom_item_id": child_row.shipment_item_id
-+								"custom_ecom_item_id": shipment_item_id
- 							})
-+							if shipment_item_id:
-+								existing_return_item_ids.add(shipment_item_id)
- 							ritems_append.append(itemcode)
- 
- 							for tax_type, rate, amount, acc_head in [
-@@ -1337,7 +1621,14 @@ class EcommerceBillImport(Document):
- 					})
- 
- 			# ---- ðŸ”¹ Update realtime progress ----
--			update_progress(count, total_invoices, f"Processed {count}/{total_invoices} invoices")
-+			percent = int((count / total_invoices) * 100) if total_invoices else 100
-+			self._publish_progress(
-+				current=count,
-+				total=total_invoices,
-+				progress=percent,
-+				message=f"Processed {count}/{total_invoices} invoices",
-+				phase="amazon_mtr_b2c",
-+			)
- 			# Commit after each invoice to reduce memory load
- 			frappe.db.commit()
- 
-@@ -1355,7 +1646,13 @@ class EcommerceBillImport(Document):
- 		self.save()
- 
- 		# ---- ðŸ”¹ Final 100% Update ----
--		update_progress(total_invoices, total_invoices, "Amazon B2C Import Completed âœ…")
-+		self._publish_progress(
-+			current=total_invoices,
-+			total=total_invoices,
-+			progress=100,
-+			message="Amazon B2C Import Completed âœ…",
-+			phase="amazon_mtr_b2c",
-+		)
- 
- 		return success_count
- 
-@@ -1373,10 +1670,24 @@ class EcommerceBillImport(Document):
- 
- 		# Group rows by invoice number
- 		for idx, row in enumerate(self.stock_transfer, 1):
--			invoice_no = row.invoice_number
-+			# Cancelled rows can have an empty invoice number; skip them to avoid creating empty groups
-+			invoice_no = (row.invoice_number or "").strip()
-+			if not invoice_no:
-+				continue
-+
- 			invoice_groups.setdefault(invoice_no, []).append((idx, row))
- 
--		total_invoices = len(invoice_groups)
-+		expected_invoices = len(invoice_groups)
-+		total_invoices = expected_invoices or 1  # avoid div-by-zero for progress
-+
-+		# ðŸ”¹ Initial progress update (Data Import-style dashboard progress)
-+		self._publish_progress(
-+			current=0,
-+			total=expected_invoices or 1,
-+			progress=0,
-+			message=f"Starting Amazon Stock Transfer import (0/{expected_invoices})" if expected_invoices else "Starting Amazon Stock Transfer import",
-+			phase="amazon_stock_transfer",
-+		)
- 
- 		# Loop through invoice groups
- 		for count, (invoice_no, group_rows) in enumerate(invoice_groups.items(), start=1):
-@@ -1444,10 +1755,15 @@ class EcommerceBillImport(Document):
- 								raise Exception(f"State name Is Wrong Please Check")
- 							doc.place_of_supply = state_code_dict.get(str(row.ship_to_state).lower())
- 
-+						qty = flt(row.quantity)
-+						# In Amazon exports, taxable_value is typically the line total (not unit rate).
-+						# ERPNext expects `rate` to be per-unit.
-+						rate = (flt(row.taxable_value) / qty) if qty else 0
-+
- 						doc.append("items", {
- 							"item_code": item_code,
--							"qty": flt(row.quantity),
--							"rate": flt(row.taxable_value),
-+							"qty": qty,
-+							"rate": rate,
- 							"warehouse": wh.erp_warehouse
- 						})
- 
-@@ -1483,7 +1799,6 @@ class EcommerceBillImport(Document):
- 					frappe.msgprint(f"{doc.doctype} {doc.name} created for Invoice No {invoice_no}")
- 
- 				# -------- Inter-company: Purchase Invoice or Receipt --------
--				print("######################",existing_name_purchase)
- 				if not existing_name_purchase:
- 					pi_doc = frappe.new_doc("Purchase Invoice" if is_taxable else "Purchase Receipt")
- 					pi_doc.supplier = ecommerce_mapping.inter_company_supplier
-@@ -1523,17 +1838,19 @@ class EcommerceBillImport(Document):
- 							location = ecommerce_mapping.default_company_location
- 							com_address = ecommerce_mapping.default_company_address
- 
--						print("#################################677478",com_address)
- 						pi_doc.location = location
- 						pi_doc.billing_address = com_address
- 					
- 						# if row.ship_to_state:
- 						# 	pi_doc.place_of_supply = state_code_dict.get(str(row.ship_to_state).lower())
- 
-+						qty = flt(row.quantity)
-+						rate = (flt(row.taxable_value) / qty) if qty else 0
-+
- 						pi_doc.append("items", {
- 							"item_code": item_code,
--							"qty": flt(row.quantity),
--							"rate": flt(row.taxable_value),
-+							"qty": qty,
-+							"rate": rate,
- 							"warehouse": warehouse,
- 						})
- 
-@@ -1577,10 +1894,12 @@ class EcommerceBillImport(Document):
- 
- 			# ðŸ”¹ Realtime progress update after each invoice group
- 			percent = int((count / total_invoices) * 100)
--			frappe.publish_realtime(
--				"data_import_progress",
--				{"progress": percent, "message": f"Processed {count}/{total_invoices} invoices"},
--				user=frappe.session.user
-+			self._publish_progress(
-+				current=count,
-+				total=total_invoices,
-+				progress=percent,
-+				message=f"Processed {count}/{total_invoices} invoices",
-+				phase="amazon_stock_transfer",
- 			)
- 
- 		# -------- Final status update --------
-@@ -1589,10 +1908,12 @@ class EcommerceBillImport(Document):
- 		self.save()
- 
- 		# ðŸ”¹ Final realtime update
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 100, "message": "Amazon Stock Transfer Import Completed âœ…"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			current=total_invoices,
-+			total=total_invoices,
-+			progress=100,
-+			message="Amazon Stock Transfer Import Completed âœ…",
-+			phase="amazon_stock_transfer",
- 		)
- 
- 		return success_count
-@@ -1606,6 +1927,10 @@ class EcommerceBillImport(Document):
- 		errors = []
- 		si_invoice = []
- 		return_invoice = []
-+		sale_existing_count = 0
-+		sale_submitted_count = 0
-+		return_existing_count = 0
-+		return_submitted_count = 0
- 
- 		customer = frappe.db.get_value("Ecommerce Mapping", {"platform": "Flipkart"}, "default_non_company_customer")
- 		flipkart = frappe.get_doc("Ecommerce Mapping", "Flipkart")
-@@ -1626,10 +1951,13 @@ class EcommerceBillImport(Document):
- 			raise Exception(f"Warehouse Mapping not found for Warehouse Id: {warehouse_id}")
- 
- 		def get_gstin(seller_gstin):
--			for gst in flipkart.ecommerce_gstin_mapping:
--				if gst.ecommerce_operator_gstin == seller_gstin:
--					return gst.ecommerce_operator_gstin
--			return None
-+			gstin = resolve_ecommerce_gstin_from_mapping(flipkart, seller_gstin)
-+			if not gstin:
-+				raise Exception(
-+					f"Ecommerce GSTIN mapping missing for Seller GSTIN: {seller_gstin}. "
-+					f"Please add it in Ecommerce Mapping '{flipkart.name}' -> Ecommerce GSTIN Mapping."
-+				)
-+			return gstin
- 
- 		# ---------- SALES ----------
- 		sale_groups = {}
-@@ -1649,7 +1977,21 @@ class EcommerceBillImport(Document):
- 
- 			sale_groups.setdefault(invoice_key, []).append(row)
- 
-+		expected_sale_invoices = len(sale_groups)
-+		total_sale_invoices = expected_sale_invoices or 1
-+		sale_count = 0
-+
-+		# ðŸ”¹ Initial progress update for sales
-+		self._publish_progress(
-+			current=0,
-+			total=total_sale_invoices,
-+			progress=0,
-+			message=f"Starting Flipkart import - Sales (0/{total_sale_invoices})",
-+			phase="flipkart_sales",
-+		)
-+
- 		for invoice_key, rows in sale_groups.items():
-+			sale_count += 1
- 			group_errors = False
- 			items_appended = 0
- 
-@@ -1660,6 +2002,16 @@ class EcommerceBillImport(Document):
- 					"docstatus": 1
- 				}, "name")
- 				if existing:
-+					sale_existing_count += 1
-+					# ðŸ”¹ Progress update before continue (no commit - will commit at end)
-+					percent = int((sale_count / total_sale_invoices) * 50)
-+					self._publish_progress(
-+						current=sale_count,
-+						total=total_sale_invoices,
-+						progress=percent,
-+						message=f"Processed {sale_count}/{total_sale_invoices} sale invoices (skipped existing)",
-+						phase="flipkart_sales",
-+					)
- 					continue
- 
- 				draft_name = frappe.db.get_value("Sales Invoice", {
-@@ -1670,6 +2022,8 @@ class EcommerceBillImport(Document):
- 
- 				if draft_name:
- 					si = frappe.get_doc("Sales Invoice", draft_name)
-+					# Ecommerce GSTIN is mandatory (enforced for draft re-runs too)
-+					si.ecommerce_gstin = get_gstin(rows[0].seller_gstin)
- 				else:
- 					first = rows[0]
- 					warehouse, location, company_address = get_warehouse_info(first.warehouse_id)
-@@ -1695,7 +2049,10 @@ class EcommerceBillImport(Document):
- 					si.ecommerce_gstin = ecommerce_gstin
- 					si.location = location
- 					si.custom_ecommerce_invoice_id = first.buyer_invoice_id
--					si.__newname = first.buyer_invoice_id
-+					# Don't set __newname if invoice with that name already exists
-+					existing_by_name = frappe.db.exists("Sales Invoice", first.buyer_invoice_id)
-+					if not existing_by_name:
-+						si.__newname = first.buyer_invoice_id
- 
- 				existing_item_ids = {
- 					d.get("custom_ecom_item_id")
-@@ -1708,21 +2065,12 @@ class EcommerceBillImport(Document):
- 						if row.order_item_id in existing_item_ids:
- 							continue
- 
--						# Skip if order_item_id already exists in non-submitted Sales Invoice Item
--						exists_in_item = frappe.db.sql("""
--							SELECT sii.name FROM `tabSales Invoice Item` sii
--							JOIN `tabSales Invoice` si ON sii.parent = si.name
--							WHERE sii.custom_ecom_item_id = %s AND si.docstatus != 1 AND si.is_return = 0
--						""", row.order_item_id)
--						if exists_in_item:
--							continue
--
- 						item_code = get_item_code(row.get(flipkart.ecom_sku_column_header))
- 						if not item_code:
- 							raise Exception(f"Item mapping not found for SKU: {row.get(flipkart.ecom_sku_column_header)}")
- 
- 						warehouse, location, company_address = get_warehouse_info(row.warehouse_id)
--						ecommerce_gstin = get_gstin(row.seller_gstin)
-+						row_ecommerce_gstin = get_gstin(row.seller_gstin)
- 
- 						# Fill missing headers (draft invoices)
- 						if not si.company_address:
-@@ -1730,7 +2078,12 @@ class EcommerceBillImport(Document):
- 						if not si.location:
- 							si.location = location
- 						if not si.ecommerce_gstin:
--							si.ecommerce_gstin = ecommerce_gstin
-+							si.ecommerce_gstin = row_ecommerce_gstin
-+						elif si.ecommerce_gstin != row_ecommerce_gstin:
-+							raise Exception(
-+								f"Multiple GSTINs detected for Buyer Invoice ID {invoice_key}: "
-+								f"{si.ecommerce_gstin} vs {row_ecommerce_gstin}"
-+							)
- 						if not si.place_of_supply and row.customers_billing_state:
- 							state = row.customers_billing_state
- 							if not state_code_dict.get(str(state).lower()):
-@@ -1738,7 +2091,10 @@ class EcommerceBillImport(Document):
- 							si.place_of_supply = state_code_dict.get(str(state).lower())
- 						if not si.custom_ecommerce_invoice_id and row.buyer_invoice_id:
- 							si.custom_ecommerce_invoice_id = row.buyer_invoice_id
--							si.__newname = row.buyer_invoice_id
-+							# Don't set __newname if invoice with that name already exists
-+							existing_by_name = frappe.db.exists("Sales Invoice", row.buyer_invoice_id)
-+							if not existing_by_name:
-+								si.__newname = row.buyer_invoice_id
- 
- 						item_name = frappe.db.get_value("Item", item_code, "item_name")
- 						hsn_code = frappe.db.get_value("Item", item_code, "gst_hsn_code")
-@@ -1789,7 +2145,7 @@ class EcommerceBillImport(Document):
- 							"message": str(row_error)
- 						})
- 
--				if items_appended > 0:
-+				if items_appended > 0 and not group_errors:
- 					si.save(ignore_permissions=True)
- 					for j in si.items:
- 						j.item_tax_template = ""
-@@ -1799,6 +2155,13 @@ class EcommerceBillImport(Document):
- 
- 				if not group_errors and si.docstatus == 0 and si.items:
- 					si_invoice.append(si.name)
-+				elif not group_errors and not si.items:
-+					errors.append({
-+						"idx": rows[0].idx if rows else "",
-+						"invoice_id": invoice_key,
-+						"event": "Sale",
-+						"message": "No items were added for this Buyer Invoice ID. Check Order Item ID parsing (scientific notation / precision loss) and duplicates."
-+					})
- 
- 			except Exception as e:
- 				for row in rows:
-@@ -1809,20 +2172,21 @@ class EcommerceBillImport(Document):
- 						"message": str(e)
- 					})
- 
--			# ðŸ”¹ Progress update after each sale invoice group
-+			# ðŸ”¹ Progress update after each sale invoice group (no commit - will commit at end)
- 			percent = int((sale_count / total_sale_invoices) * 50)  # Sales take first 50% of progress
--			frappe.publish_realtime(
--				"data_import_progress",
--				{"progress": percent, "message": f"Processed {sale_count}/{total_sale_invoices} sale invoices"},
--				user=frappe.session.user
-+			self._publish_progress(
-+				current=sale_count,
-+				total=total_sale_invoices,
-+				progress=percent,
-+				message=f"Processed {sale_count}/{total_sale_invoices} sale invoices",
-+				phase="flipkart_sales",
- 			)
--			frappe.db.commit()
- 
--		# Submit Sales Invoices
-+		# Submit Sales Invoices (no commits during loop - will commit at end)
- 		for sii in si_invoice:
- 			try:
- 				frappe.get_doc("Sales Invoice", sii).submit()
--				frappe.db.commit()
-+				sale_submitted_count += 1
- 			except Exception as e:
- 				errors.append({
- 					"idx": "",
-@@ -1849,7 +2213,21 @@ class EcommerceBillImport(Document):
- 
- 			return_groups.setdefault(invoice_key, []).append(row)
- 
-+		expected_return_invoices = len(return_groups)
-+		total_return_invoices = expected_return_invoices or 1
-+		return_count = 0
-+
-+		# ðŸ”¹ Progress update for returns (starts at 50%)
-+		self._publish_progress(
-+			current=0,
-+			total=total_return_invoices,
-+			progress=50,
-+			message=f"Starting Returns (0/{total_return_invoices})",
-+			phase="flipkart_returns",
-+		)
-+
- 		for invoice_key, rows in return_groups.items():
-+			return_count += 1
- 			group_errors = False
- 			items_appended = 0
- 
-@@ -1860,6 +2238,16 @@ class EcommerceBillImport(Document):
- 					"docstatus": 1
- 				}, "name")
- 				if existing_return:
-+					return_existing_count += 1
-+					# ðŸ”¹ Progress update before continue (no commit - will commit at end)
-+					percent = 50 + int((return_count / total_return_invoices) * 50)
-+					self._publish_progress(
-+						current=return_count,
-+						total=total_return_invoices,
-+						progress=percent,
-+						message=f"Processed {return_count}/{total_return_invoices} return invoices (skipped existing)",
-+						phase="flipkart_returns",
-+					)
- 					continue
- 
- 				draft_name = frappe.db.get_value("Sales Invoice", {
-@@ -1871,6 +2259,8 @@ class EcommerceBillImport(Document):
- 				if draft_name:
- 					si = frappe.get_doc("Sales Invoice", draft_name)
- 					si.is_return = 1
-+					# Ecommerce GSTIN is mandatory (enforced for draft re-runs too)
-+					si.ecommerce_gstin = get_gstin(rows[0].seller_gstin)
- 				else:
- 					first = rows[0]
- 					warehouse, location, company_address = get_warehouse_info(first.warehouse_id)
-@@ -1895,7 +2285,10 @@ class EcommerceBillImport(Document):
- 					si.location = location
- 					si.is_return = 1
- 					si.custom_ecommerce_invoice_id = first.buyer_invoice_id
--					si.__newname = first.buyer_invoice_id
-+					# Don't set __newname if invoice with that name already exists
-+					existing_by_name = frappe.db.exists("Sales Invoice", first.buyer_invoice_id)
-+					if not existing_by_name:
-+						si.__newname = first.buyer_invoice_id
- 
- 				existing_item_ids = {
- 					d.get("custom_ecom_item_id")
-@@ -1908,27 +2301,24 @@ class EcommerceBillImport(Document):
- 						if row.order_item_id in existing_item_ids:
- 							continue
- 
--						exists_in_item = frappe.db.sql("""
--							SELECT sii.name FROM `tabSales Invoice Item` sii
--							JOIN `tabSales Invoice` si ON sii.parent = si.name
--							WHERE sii.custom_ecom_item_id = %s AND si.docstatus != 1 AND si.is_return = 1
--						""", row.order_item_id)
--						if exists_in_item:
--							continue
--
- 						item_code = get_item_code(row.get(flipkart.ecom_sku_column_header))
- 						if not item_code:
- 							raise Exception(f"Item mapping not found for SKU: {row.get(flipkart.ecom_sku_column_header)}")
- 
- 						warehouse, location, company_address = get_warehouse_info(row.warehouse_id)
--						ecommerce_gstin = get_gstin(row.seller_gstin)
-+						row_ecommerce_gstin = get_gstin(row.seller_gstin)
- 
- 						if not si.company_address:
- 							si.company_address = company_address
- 						if not si.location:
- 							si.location = location
- 						if not si.ecommerce_gstin:
--							si.ecommerce_gstin = ecommerce_gstin
-+							si.ecommerce_gstin = row_ecommerce_gstin
-+						elif si.ecommerce_gstin != row_ecommerce_gstin:
-+							raise Exception(
-+								f"Multiple GSTINs detected for Buyer Invoice ID {invoice_key}: "
-+								f"{si.ecommerce_gstin} vs {row_ecommerce_gstin}"
-+							)
- 						if not si.place_of_supply and row.customers_billing_state:
- 							state = row.customers_billing_state
- 							if not state_code_dict.get(str(state).lower()):
-@@ -1936,7 +2326,10 @@ class EcommerceBillImport(Document):
- 							si.place_of_supply = state_code_dict.get(str(state).lower())
- 						if not si.custom_ecommerce_invoice_id and row.buyer_invoice_id:
- 							si.custom_ecommerce_invoice_id = row.buyer_invoice_id
--							si.__newname = row.buyer_invoice_id
-+							# Don't set __newname if invoice with that name already exists
-+							existing_by_name = frappe.db.exists("Sales Invoice", row.buyer_invoice_id)
-+							if not existing_by_name:
-+								si.__newname = row.buyer_invoice_id
- 
- 						item_name = frappe.db.get_value("Item", item_code, "item_name")
- 						hsn_code = frappe.db.get_value("Item", item_code, "gst_hsn_code")
-@@ -1984,7 +2377,7 @@ class EcommerceBillImport(Document):
- 							"message": str(row_error)
- 						})
- 
--				if items_appended > 0:
-+				if items_appended > 0 and not group_errors:
- 					si.save(ignore_permissions=True)
- 					for j in si.items:
- 						j.item_tax_template = ""
-@@ -1994,6 +2387,13 @@ class EcommerceBillImport(Document):
- 
- 				if not group_errors and si.docstatus == 0 and si.items:
- 					return_invoice.append(si.name)
-+				elif not group_errors and not si.items:
-+					errors.append({
-+						"idx": rows[0].idx if rows else "",
-+						"invoice_id": invoice_key,
-+						"event": "Return",
-+						"message": "No items were added for this Buyer Invoice ID (Return). Check Order Item ID parsing (scientific notation / precision loss) and duplicates."
-+					})
- 
- 			except Exception as e:
- 				for row in rows:
-@@ -2004,20 +2404,21 @@ class EcommerceBillImport(Document):
- 						"message": str(e)
- 					})
- 
--			# ðŸ”¹ Progress update after each return invoice group
-+			# ðŸ”¹ Progress update after each return invoice group (no commit - will commit at end)
- 			percent = 50 + int((return_count / total_return_invoices) * 50)  # Returns take last 50% of progress
--			frappe.publish_realtime(
--				"data_import_progress",
--				{"progress": percent, "message": f"Processed {return_count}/{total_return_invoices} return invoices"},
--				user=frappe.session.user
-+			self._publish_progress(
-+				current=return_count,
-+				total=total_return_invoices,
-+				progress=percent,
-+				message=f"Processed {return_count}/{total_return_invoices} return invoices",
-+				phase="flipkart_returns",
- 			)
--			frappe.db.commit()
- 
--		# Submit Return Invoices
-+		# Submit Return Invoices (no commits during loop - will commit at end)
- 		for sii in return_invoice:
- 			try:
- 				frappe.get_doc("Sales Invoice", sii).submit()
--				frappe.db.commit()
-+				return_submitted_count += 1
- 			except Exception as e:
- 				errors.append({
- 					"idx": "",
-@@ -2026,19 +2427,44 @@ class EcommerceBillImport(Document):
- 					"message": f"Submit failed: {str(e)}"
- 				})
- 
-+		# ðŸ”¹ Commit all changes at the end (like submit_after_import in data import)
-+		frappe.db.commit()
-+
- 		self.error_json = str(json.dumps(errors))
--		if len(errors) == 0:
-+		expected_total = expected_sale_invoices + expected_return_invoices
-+		completed_total = sale_existing_count + sale_submitted_count + return_existing_count + return_submitted_count
-+
-+		if expected_total == 0:
-+			self.status = "Error"
-+		elif completed_total == expected_total and not errors:
- 			self.status = "Success"
--		elif len(self.flipkart_items) != len(errors):
--			self.status = "Partial Success"
--		else:
-+		elif completed_total == 0:
- 			self.status = "Error"
-+		else:
-+			self.status = "Partial Success"
- 
- 		self.save(ignore_permissions=True)
- 
-+		# ðŸ”¹ Final progress update
-+		self._publish_progress(
-+			current=expected_total,
-+			total=expected_total,
-+			progress=100,
-+			message="Flipkart Import Completed âœ…",
-+			phase="flipkart",
-+		)
-+
- 		return {
--			"status": "partial" if errors else "success",
--			"errors": errors
-+			"status": "success" if self.status == "Success" else "partial",
-+			"errors": errors,
-+			"summary": {
-+				"expected_sale_invoices": expected_sale_invoices,
-+				"expected_return_invoices": expected_return_invoices,
-+				"sale_existing": sale_existing_count,
-+				"sale_submitted": sale_submitted_count,
-+				"return_existing": return_existing_count,
-+				"return_submitted": return_submitted_count,
-+			},
- 		}
- 
- 
-@@ -2060,10 +2486,12 @@ class EcommerceBillImport(Document):
- 		cred_count = 0
- 
- 		# ðŸ”¹ Initial progress update
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 0, "message": f"Starting CRED import (0/{total_cred_items})"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			current=0,
-+			total=total_cred_items,
-+			progress=0,
-+			message=f"Starting CRED import (0/{total_cred_items})",
-+			phase="cred_shipments",
- 		)
- 
- 		# Shipment Invoice
-@@ -2107,8 +2535,12 @@ class EcommerceBillImport(Document):
- 					# customer_address_in_state=amazon.customer_address_in_state
- 					# customer_address_out_state=amazon.customer_address_out_state
- 
--				gstin_data = next((gstin for gstin in amazon.ecommerce_gstin_mapping if gstin.ecommerce_operator_gstin == i.seller_gstin), None)
--				ecommerce_gstin = gstin_data.ecommerce_operator_gstin if gstin_data else ""
-+				ecommerce_gstin = resolve_ecommerce_gstin_from_mapping(amazon, i.seller_gstin)
-+				if not ecommerce_gstin:
-+					raise Exception(
-+						f"Ecommerce GSTIN mapping missing for Seller GSTIN: {i.seller_gstin}. "
-+						f"Please add it in Ecommerce Mapping '{amazon.name}' -> Ecommerce GSTIN Mapping."
-+					)
- 
- 				si = frappe.new_doc("Sales Invoice") if not si_inv else frappe.get_doc("Sales Invoice", si_inv_draft)
- 				si.customer = val
-@@ -2173,10 +2605,12 @@ class EcommerceBillImport(Document):
- 
- 				# ðŸ”¹ Progress update after each invoice
- 				percent = int((cred_count / total_cred_items) * 50)  # Shipments take first 50%
--				frappe.publish_realtime(
--					"data_import_progress",
--					{"progress": percent, "message": f"Processed {cred_count}/{total_cred_items} shipment invoices"},
--					user=frappe.session.user
-+				self._publish_progress(
-+					current=cred_count,
-+					total=total_cred_items,
-+					progress=percent,
-+					message=f"Processed {cred_count}/{total_cred_items} shipment invoices",
-+					phase="cred_shipments",
- 				)
- 
- 			except Exception as e:
-@@ -2205,10 +2639,12 @@ class EcommerceBillImport(Document):
- 		return_count = 0
- 
- 		# ðŸ”¹ Progress update for returns (starts at 50%)
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 50, "message": f"Starting Returns (0/{total_return_items})"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			current=0,
-+			total=total_return_items,
-+			progress=50,
-+			message=f"Starting Returns (0/{total_return_items})",
-+			phase="cred_returns",
- 		)
- 
- 		for i in self.cred_items:
-@@ -2243,7 +2679,6 @@ class EcommerceBillImport(Document):
- 						"message": "Missing item code or warehouse mapping"
- 					})
- 					continue
--				print("#########################",itemcode)
- 				warehouse = warehouse_data.erp_warehouse
- 				location = warehouse_data.location
- 				com_address = warehouse_data.erp_address
-@@ -2257,10 +2692,12 @@ class EcommerceBillImport(Document):
- 					# customer_address_in_state=amazon.customer_address_in_state
- 					# customer_address_out_state=amazon.customer_address_out_state
- 				# company_gstin = frappe.db.get_value("Address", com_address, "gstin")
--				gstin_data = next((gstin for gstin in amazon.ecommerce_gstin_mapping if gstin.ecommerce_operator_gstin == i.seller_gstin), None)
--				ecommerce_gstin=None
--				if gstin_data:
--					ecommerce_gstin = gstin_data.ecommerce_operator_gstin
-+				ecommerce_gstin = resolve_ecommerce_gstin_from_mapping(amazon, i.seller_gstin)
-+				if not ecommerce_gstin:
-+					raise Exception(
-+						f"Ecommerce GSTIN mapping missing for Seller GSTIN: {i.seller_gstin}. "
-+						f"Please add it in Ecommerce Mapping '{amazon.name}' -> Ecommerce GSTIN Mapping."
-+					)
- 
- 				si = frappe.new_doc("Sales Invoice") if not si_inv else frappe.get_doc("Sales Invoice", si_inv_draft)
- 				si.customer = val
-@@ -2324,10 +2761,12 @@ class EcommerceBillImport(Document):
- 
- 				# ðŸ”¹ Progress update after each return invoice
- 				percent = 50 + int((return_count / total_return_items) * 50)  # Returns take last 50%
--				frappe.publish_realtime(
--					"data_import_progress",
--					{"progress": percent, "message": f"Processed {return_count}/{total_return_items} return invoices"},
--					user=frappe.session.user
-+				self._publish_progress(
-+					current=return_count,
-+					total=total_return_items,
-+					progress=percent,
-+					message=f"Processed {return_count}/{total_return_items} return invoices",
-+					phase="cred_returns",
- 				)
- 
- 			except Exception as e:
-@@ -2352,10 +2791,10 @@ class EcommerceBillImport(Document):
- 				})
- 
- 		# ðŸ”¹ Final progress update
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 100, "message": "CRED Import Completed âœ…"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			progress=100,
-+			message="CRED Import Completed âœ…",
-+			phase="cred",
- 		)
- 
- 		# Save all errors in test_json
-@@ -2393,11 +2832,34 @@ class EcommerceBillImport(Document):
- 			return jiomart.default_company_warehouse, jiomart.default_company_location, jiomart.default_company_address
- 
- 		def get_gstin(seller_gstin):
--			# company_gstin = frappe.db.get_value("Address", company_address, "gstin")
--			for gst in jiomart.ecommerce_gstin_mapping:
--				if gst.ecommerce_operator_gstin == seller_gstin:
--					return gst.ecommerce_operator_gstin
--			return None
-+			"""Resolve optional Ecommerce Operator (TCS) GSTIN for JioMart.
-+
-+			JioMart imports should not fail if GSTIN mapping is missing or invalid.
-+			If mapping isn't found or doesn't pass TCS GSTIN validation, return None and
-+			allow invoice creation to proceed without `ecommerce_gstin`.
-+			"""
-+			gstin = (str(seller_gstin).strip().upper() if seller_gstin is not None else "")
-+			if not gstin:
-+				return None
-+
-+			operator_gstin = None
-+			for row in (getattr(jiomart, "ecommerce_gstin_mapping", None) or []):
-+				mapped_operator = (row.ecommerce_operator_gstin or "").strip().upper()
-+				mapped_company = (row.erp_company_gstin or "").strip().upper()
-+				if gstin == mapped_operator or gstin == mapped_company:
-+					operator_gstin = mapped_operator
-+					break
-+
-+			if not operator_gstin:
-+				return None
-+
-+			# Validate as TCS GSTIN; if invalid, ignore and proceed without ecommerce_gstin
-+			try:
-+				from india_compliance.gst_india.utils import validate_gstin as _validate_gstin
-+
-+				return _validate_gstin(operator_gstin, label="E-commerce GSTIN", is_tcs_gstin=True)
-+			except Exception:
-+				return None
- 
- 		# ---------- SALES ----------
- 		sale_groups = {}
-@@ -2421,10 +2883,12 @@ class EcommerceBillImport(Document):
- 		sale_count = 0
- 
- 		# ðŸ”¹ Initial progress update for sales
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 0, "message": f"Starting JioMart import - Sales (0/{total_sale_invoices})"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			current=0,
-+			total=total_sale_invoices,
-+			progress=0,
-+			message=f"Starting JioMart import - Sales (0/{total_sale_invoices})",
-+			phase="jiomart_sales",
- 		)
- 
- 		for invoice_key, rows in sale_groups.items():
-@@ -2439,6 +2903,16 @@ class EcommerceBillImport(Document):
- 					"docstatus": 1
- 				}, "name")
- 				if existing:
-+					# Sales invoice already submitted; treat as processed and keep progress moving
-+					percent = int((sale_count / total_sale_invoices) * 50) if total_sale_invoices else 50
-+					self._publish_progress(
-+						current=sale_count,
-+						total=total_sale_invoices,
-+						progress=percent,
-+						message=f"Processed {sale_count}/{total_sale_invoices} sale invoices (skipped existing)",
-+						phase="jiomart_sales",
-+					)
-+					frappe.db.commit()
- 					continue
- 
- 				draft_name = frappe.db.get_value("Sales Invoice", {
-@@ -2451,6 +2925,8 @@ class EcommerceBillImport(Document):
- 
- 				if draft_name:
- 					si = frappe.get_doc("Sales Invoice", draft_name)
-+					# Optional for JioMart: set if resolvable, else clear
-+					si.ecommerce_gstin = get_gstin(rows[0].seller_gstin) or ""
- 				else:
- 					first = rows[0]
- 					ecommerce_gstin = get_gstin(first.seller_gstin)
-@@ -2471,8 +2947,11 @@ class EcommerceBillImport(Document):
- 					si.update_stock = 1
- 					si.company_address = company_address
- 					si.custom_ecommerce_invoice_id = first.buyer_invoice_id
--					si.__newname = first.buyer_invoice_id
--					si.ecommerce_gstin = ecommerce_gstin
-+					# Avoid duplicate primary key errors if an invoice with this name already exists
-+					existing_by_name = frappe.db.exists("Sales Invoice", first.buyer_invoice_id)
-+					if not existing_by_name:
-+						si.__newname = first.buyer_invoice_id
-+					si.ecommerce_gstin = ecommerce_gstin or ""
- 					si.location = location
- 
- 				existing_item_ids = {
-@@ -2486,15 +2965,6 @@ class EcommerceBillImport(Document):
- 						if row.order_item_id in existing_item_ids:
- 							continue
- 
--						# Skip if order_item_id already exists in non-submitted Sales Invoice Item
--						exists_in_item = frappe.db.sql("""
--							SELECT sii.name FROM `tabSales Invoice Item` sii
--							JOIN `tabSales Invoice` si ON sii.parent = si.name
--							WHERE sii.custom_ecom_item_id = %s AND si.docstatus != 1 AND si.is_return = 0
--						""", row.order_item_id)
--						if exists_in_item:
--							continue
--
- 						item_code = get_item_code(row.get(jiomart.ecom_sku_column_header))
- 						if not item_code:
- 							raise Exception(f"Item mapping not found for SKU: {row.get(jiomart.ecom_sku_column_header)}")
-@@ -2502,11 +2972,15 @@ class EcommerceBillImport(Document):
- 						item_name = frappe.db.get_value("Item", item_code, "item_name")
- 						hsn_code = frappe.db.get_value("Item", item_code, "gst_hsn_code")
- 
-+						qty = flt(row.item_quantity)
-+						# JioMart export taxable_value is a line total; ERPNext expects per-unit rate
-+						rate = (flt(row.taxable_value) / qty) if qty else 0
-+
- 						item_row = {
- 							"item_code": item_code,
- 							"item_name": item_name,
--							"qty": flt(row.item_quantity),
--							"rate": flt(row.taxable_value),
-+							"qty": qty,
-+							"rate": rate,
- 							"gst_hsn_code": hsn_code,
- 							"description": row.product_titledescription,
- 							"warehouse": warehouse,
-@@ -2517,13 +2991,19 @@ class EcommerceBillImport(Document):
- 						}
- 
- 						# Fill missing headers (draft invoices)
--						ecommerce_gstin = get_gstin(row.seller_gstin)
-+						row_ecommerce_gstin = get_gstin(row.seller_gstin)
- 						if not si.company_address:
- 							si.company_address = company_address
- 						if not si.location:
- 							si.location = location
--						if not si.ecommerce_gstin:
--							si.ecommerce_gstin = ecommerce_gstin
-+						# Optional for JioMart:
-+						# - if we can resolve a single GSTIN, set it
-+						# - if rows disagree, clear it and proceed (don't block submission)
-+						if row_ecommerce_gstin:
-+							if not si.ecommerce_gstin:
-+								si.ecommerce_gstin = row_ecommerce_gstin
-+							elif si.ecommerce_gstin != row_ecommerce_gstin:
-+								si.ecommerce_gstin = ""
- 						if not si.place_of_supply and row.customers_billing_state:
- 							state = row.customers_billing_state
- 							if not state_code_dict.get(str(state).lower()):
-@@ -2585,10 +3065,12 @@ class EcommerceBillImport(Document):
- 
- 			# ðŸ”¹ Progress update after each sale invoice group
- 			percent = int((sale_count / total_sale_invoices) * 50)  # Sales take first 50% of progress
--			frappe.publish_realtime(
--				"data_import_progress",
--				{"progress": percent, "message": f"Processed {sale_count}/{total_sale_invoices} sale invoices"},
--				user=frappe.session.user
-+			self._publish_progress(
-+				current=sale_count,
-+				total=total_sale_invoices,
-+				progress=percent,
-+				message=f"Processed {sale_count}/{total_sale_invoices} sale invoices",
-+				phase="jiomart_sales",
- 			)
- 			frappe.db.commit()
- 
-@@ -2627,10 +3109,12 @@ class EcommerceBillImport(Document):
- 		return_count = 0
- 
- 		# ðŸ”¹ Progress update for returns (starts at 50%)
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 50, "message": f"Starting Returns (0/{total_return_invoices})"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			current=0,
-+			total=total_return_invoices,
-+			progress=50,
-+			message=f"Starting Returns (0/{total_return_invoices})",
-+			phase="jiomart_returns",
- 		)
- 
- 		for invoice_key, rows in return_groups.items():
-@@ -2645,6 +3129,16 @@ class EcommerceBillImport(Document):
- 					"docstatus": 1
- 				}, "name")
- 				if existing_return:
-+					# Return invoice already submitted; treat as processed and keep progress moving
-+					percent = 50 + (int((return_count / total_return_invoices) * 50) if total_return_invoices else 50)
-+					self._publish_progress(
-+						current=return_count,
-+						total=total_return_invoices,
-+						progress=percent,
-+						message=f"Processed {return_count}/{total_return_invoices} return invoices (skipped existing)",
-+						phase="jiomart_returns",
-+					)
-+					frappe.db.commit()
- 					continue
- 
- 				draft_name = frappe.db.get_value("Sales Invoice", {
-@@ -2658,6 +3152,8 @@ class EcommerceBillImport(Document):
- 				if draft_name:
- 					si = frappe.get_doc("Sales Invoice", draft_name)
- 					si.is_return = 1
-+					# Optional for JioMart: set if resolvable, else clear
-+					si.ecommerce_gstin = get_gstin(rows[0].seller_gstin) or ""
- 				else:
- 					first = rows[0]
- 					ecommerce_gstin = get_gstin(first.seller_gstin)
-@@ -2672,11 +3168,14 @@ class EcommerceBillImport(Document):
- 					si.taxes_and_charges = ""
- 					si.update_stock = 1
- 					si.company_address = company_address
--					si.ecommerce_gstin = ecommerce_gstin
-+					si.ecommerce_gstin = ecommerce_gstin or ""
- 					si.location = location
- 					si.is_return = 1
- 					si.custom_ecommerce_invoice_id = first.buyer_invoice_id
--					si.__newname = first.buyer_invoice_id
-+					# Avoid duplicate primary key errors if an invoice with this name already exists
-+					existing_by_name = frappe.db.exists("Sales Invoice", first.buyer_invoice_id)
-+					if not existing_by_name:
-+						si.__newname = first.buyer_invoice_id
- 					if first.customers_billing_state:
- 						state = first.customers_billing_state
- 						if not state_code_dict.get(str(state).lower()):
-@@ -2694,14 +3193,6 @@ class EcommerceBillImport(Document):
- 						if row.order_item_id in existing_item_ids:
- 							continue
- 
--						exists_in_item = frappe.db.sql("""
--							SELECT sii.name FROM `tabSales Invoice Item` sii
--							JOIN `tabSales Invoice` si ON sii.parent = si.name
--							WHERE sii.custom_ecom_item_id = %s AND si.docstatus != 1 AND si.is_return = 1
--						""", row.order_item_id)
--						if exists_in_item:
--							continue
--
- 						item_code = get_item_code(row.get(jiomart.ecom_sku_column_header))
- 						if not item_code:
- 							raise Exception(f"Item mapping not found for SKU: {row.get(jiomart.ecom_sku_column_header)}")
-@@ -2709,11 +3200,15 @@ class EcommerceBillImport(Document):
- 						item_name = frappe.db.get_value("Item", item_code, "item_name")
- 						hsn_code = frappe.db.get_value("Item", item_code, "gst_hsn_code")
- 
-+						qty_abs = abs(flt(row.item_quantity))
-+						# Return: rate must be per-unit, qty negative
-+						rate = (abs(flt(row.taxable_value)) / qty_abs) if qty_abs else 0
-+
- 						item_row = {
- 							"item_code": item_code,
- 							"item_name": item_name,
--							"qty": -abs(flt(row.item_quantity)),
--							"rate": abs(flt(row.taxable_value)),
-+							"qty": -qty_abs,
-+							"rate": rate,
- 							"gst_hsn_code": hsn_code,
- 							"description": row.product_titledescription,
- 							"warehouse": warehouse,
-@@ -2723,13 +3218,16 @@ class EcommerceBillImport(Document):
- 							"custom_ecom_item_id": row.order_item_id
- 						}
- 
--						ecommerce_gstin = get_gstin(row.seller_gstin)
-+						row_ecommerce_gstin = get_gstin(row.seller_gstin)
- 						if not si.company_address:
- 							si.company_address = company_address
- 						if not si.location:
- 							si.location = location
--						if not si.ecommerce_gstin:
--							si.ecommerce_gstin = ecommerce_gstin
-+						if row_ecommerce_gstin:
-+							if not si.ecommerce_gstin:
-+								si.ecommerce_gstin = row_ecommerce_gstin
-+							elif si.ecommerce_gstin != row_ecommerce_gstin:
-+								si.ecommerce_gstin = ""
- 						if not si.place_of_supply and row.customers_billing_state:
- 							state = row.customers_billing_state
- 							if not state_code_dict.get(str(state).lower()):
-@@ -2737,7 +3235,10 @@ class EcommerceBillImport(Document):
- 							si.place_of_supply = state_code_dict.get(str(state).lower())
- 						if not si.custom_ecommerce_invoice_id and row.buyer_invoice_id:
- 							si.custom_ecommerce_invoice_id = row.buyer_invoice_id
--							si.__newname = row.buyer_invoice_id
-+							# Avoid duplicate primary key errors if an invoice with this name already exists
-+							existing_by_name = frappe.db.exists("Sales Invoice", row.buyer_invoice_id)
-+							if not existing_by_name:
-+								si.__newname = row.buyer_invoice_id
- 
- 						si.append("items", item_row)
- 						existing_item_ids.add(row.order_item_id)
-@@ -2791,10 +3292,12 @@ class EcommerceBillImport(Document):
- 
- 			# ðŸ”¹ Progress update after each return invoice group
- 			percent = 50 + int((return_count / total_return_invoices) * 50)  # Returns take last 50% of progress
--			frappe.publish_realtime(
--				"data_import_progress",
--				{"progress": percent, "message": f"Processed {return_count}/{total_return_invoices} return invoices"},
--				user=frappe.session.user
-+			self._publish_progress(
-+				current=return_count,
-+				total=total_return_invoices,
-+				progress=percent,
-+				message=f"Processed {return_count}/{total_return_invoices} return invoices",
-+				phase="jiomart_returns",
- 			)
- 			frappe.db.commit()
- 
-@@ -2812,10 +3315,10 @@ class EcommerceBillImport(Document):
- 				})
- 
- 		# ðŸ”¹ Final progress update
--		frappe.publish_realtime(
--			"data_import_progress",
--			{"progress": 100, "message": "JioMart Import Completed âœ…"},
--			user=frappe.session.user
-+		self._publish_progress(
-+			progress=100,
-+			message="JioMart Import Completed âœ…",
-+			phase="jiomart",
- 		)
- 
- 		self.error_json = str(json.dumps(errors))
-@@ -2872,10 +3375,6 @@ def generate_error_html(errors):
- 
- 
- def update_progress(current, total, message="Processing..."):
--    """Send realtime progress to the frontend"""
--    percent = int((current / total) * 100) if total else 100
--    frappe.publish_realtime(
--        "data_import_progress",
--        {"progress": percent, "message": message},
--        user=frappe.session.user
--    )
-+    """Deprecated helper (kept for backward compatibility)."""
-+    # Use EcommerceBillImport._publish_progress instead.
-+    return
diff --git a/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py b/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
index 098b240..2f59b4a 100644
--- a/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
+++ b/ecom_import_tool/ecom_import_tool/doctype/ecommerce_bill_import/ecommerce_bill_import.py
@@ -78,6 +78,99 @@ def clean_csv_cell(val):
 	return s
 
 
+def parse_export_datetime(value):
+	"""Parse export date/datetime with a day-first preference (DD-MM-YYYY).
+
+	Why this exists:
+	- Some platform exports provide dates like "01-12-2025" which are day-first.
+	- `getdate()` can interpret ambiguous strings as month-first depending on settings.
+	- For e-commerce imports we want deterministic India-style parsing.
+	"""
+	if not value:
+		return None
+
+	if isinstance(value, datetime):
+		return value
+
+	# Pandas Timestamp / Excel-derived value support
+	if hasattr(value, "to_pydatetime"):
+		try:
+			return value.to_pydatetime()
+		except Exception:
+			pass
+
+	s = clean_csv_cell(value)
+	if not s:
+		return None
+
+	s = s.replace("\u00a0", " ").strip()
+
+	# Try common day-first formats first
+	for fmt in (
+		"%d-%m-%Y %H:%M:%S",
+		"%d-%m-%Y %H:%M",
+		"%d/%m/%Y %H:%M:%S",
+		"%d/%m/%Y %H:%M",
+		"%d-%m-%Y",
+		"%d/%m/%Y",
+		"%d-%m-%y %H:%M:%S",
+		"%d-%m-%y %H:%M",
+		"%d/%m/%y %H:%M:%S",
+		"%d/%m/%y %H:%M",
+		"%d-%m-%y",
+		"%d/%m/%y",
+		"%Y-%m-%d %H:%M:%S",
+		"%Y-%m-%d %H:%M",
+		"%Y/%m/%d %H:%M:%S",
+		"%Y/%m/%d %H:%M",
+		"%Y-%m-%d",
+		"%Y/%m/%d",
+	):
+		try:
+			return datetime.strptime(s, fmt)
+		except Exception:
+			pass
+
+	# Common case: extra suffixes; try trimming to 19 chars (YYYY-MM-DD HH:MM:SS / DD-MM-YYYY HH:MM:SS)
+	s19 = s[:19]
+	for fmt in ("%d-%m-%Y %H:%M:%S", "%Y-%m-%d %H:%M:%S", "%d/%m/%Y %H:%M:%S"):
+		try:
+			return datetime.strptime(s19, fmt)
+		except Exception:
+			pass
+
+	# Last resort: dateutil parser with dayfirst=True
+	try:
+		from dateutil import parser as date_parser
+
+		return date_parser.parse(s, dayfirst=True)
+	except Exception:
+		return None
+
+
+def parse_export_date(value):
+	"""Return a date from an export value (date or datetime string)."""
+	dt = parse_export_datetime(value)
+	return dt.date() if dt else None
+
+
+def parse_export_time(value):
+	"""Return a time from an export value (date or datetime string)."""
+	dt = parse_export_datetime(value)
+	return dt.time() if dt else None
+
+
+def normalize_tax_rate(rate):
+	"""Normalize tax rate to the percentage ERPNext expects (e.g. 5 for 5%).
+
+	Some sources provide 0.05 (fraction) and some provide 5 (percent).
+	"""
+	rate = flt(rate)
+	if 0 < rate < 1:
+		return rate * 100
+	return rate
+
+
 def resolve_ecommerce_gstin_from_mapping(ecommerce_mapping, seller_gstin):
 	"""Resolve `Sales Invoice.ecommerce_gstin` from `Ecommerce Mapping.ecommerce_gstin_mapping`.
 
@@ -401,7 +494,7 @@ class EcommerceBillImport(Document):
 			# Sort by invoice date for stable grouping/processing downstream
 			if self.mtr_b2b:
 					self.mtr_b2b.sort(
-						key=lambda x: getdate(x.invoice_date) if x.invoice_date else frappe.utils.getdate("1900-01-01")
+						key=lambda x: parse_export_date(x.invoice_date) or frappe.utils.getdate("1900-01-01")
 				)
 
 	def append_mtr_b2c(self):
@@ -442,7 +535,7 @@ class EcommerceBillImport(Document):
 			if self.mtr_b2c:
 				# Use getdate to handle ERPNext date parsing
 				self.mtr_b2c.sort(
-					key=lambda x: getdate(x.invoice_date) if x.invoice_date else frappe.utils.getdate("1900-01-01")
+					key=lambda x: parse_export_date(x.invoice_date) or frappe.utils.getdate("1900-01-01")
             )
 
 	
@@ -486,7 +579,7 @@ class EcommerceBillImport(Document):
 			if self.stock_transfer:
 				# Use getdate to handle ERPNext date parsing
 				self.stock_transfer.sort(
-					key=lambda x: getdate(x.invoice_date) if x.invoice_date else frappe.utils.getdate("1900-01-01")
+					key=lambda x: parse_export_date(x.invoice_date) or frappe.utils.getdate("1900-01-01")
             )
 				
 	
@@ -503,6 +596,7 @@ class EcommerceBillImport(Document):
 			return
 
 		import os
+		import pandas as pd
 		from frappe.utils.file_manager import get_file_path
 
 		file_url = self.cred_attach
@@ -512,13 +606,9 @@ class EcommerceBillImport(Document):
 		if not os.path.exists(file_path):
 			frappe.throw(f"File not found at path: {file_path}")
 
-		ext = os.path.splitext(filename)[1].lower()
-		if ext != ".csv":
-			frappe.throw("Please upload the CRED export in CSV format (.csv).")
-
 		ext = os.path.splitext(filename)[1].lower()
 		if ext == ".csv":
-			# Validate CSV is readable and count rows (optional)
+			# CSV: validate only (invoice creation reads CSV directly in background job)
 			try:
 				df = pd.read_csv(
 					file_path,
@@ -533,10 +623,9 @@ class EcommerceBillImport(Document):
 			return
 
 		# ---------------- Legacy Excel (kept for backward compatibility) ----------------
-		import os
 
-		# Helper function to clean and convert Excel values
 		def clean(val):
+			"""Normalize Excel cell values to string/date."""
 			if pd.isna(val):
 				return ""
 
@@ -547,7 +636,6 @@ class EcommerceBillImport(Document):
 				except Exception:
 					pass
 
-			# If it's already a datetime object
 			if isinstance(val, datetime):
 				return val.strftime("%Y-%m-%d")
 
@@ -556,27 +644,28 @@ class EcommerceBillImport(Document):
 			except Exception:
 				return str(val)
 
-		# Read Excel file using appropriate sheet rows
-		df = pd.read_excel(file_path, sheet_name=1)
-		df2 = pd.read_excel(file_path, sheet_name=0)
+		df_returns = pd.read_excel(file_path, sheet_name=1)
+		df_sales = pd.read_excel(file_path, sheet_name=0)
 
-		# Map sheet-1 -> cred_items (returns), sheet-0 -> cred (sales)
 		return_child_doctype = frappe.get_meta(self.doctype).get_field("cred_items").options
-		return_meta = frappe.get_meta(return_child_doctype)
-		return_fields = {f.fieldname for f in return_meta.fields}
+		sale_child_doctype = frappe.get_meta(self.doctype).get_field("cred").options
 
-		for _, row in df.iterrows():
+		return_fields = {f.fieldname for f in frappe.get_meta(return_child_doctype).fields}
+		sale_fields = {f.fieldname for f in frappe.get_meta(sale_child_doctype).fields}
+
+		for _, row in df_returns.iterrows():
 			child_row = self.append("cred_items", {})
-			for column_name in df.columns:
+			for column_name in df_returns.columns:
 				fieldname = column_name.strip().lower().replace(" ", "_")
 				if fieldname in return_fields:
 					child_row.set(fieldname, clean(row[column_name]))
 
-		for _, row in df2.iterrows():
+		for _, row in df_sales.iterrows():
 			child_row = self.append("cred", {})
-			for column_name in df2.columns:
+			for column_name in df_sales.columns:
 				fieldname = column_name.strip().lower().replace(" ", "_")
-				child_row.set(fieldname, clean(row[column_name]))
+				if fieldname in sale_fields:
+					child_row.set(fieldname, clean(row[column_name]))
 
 	def append_flipkart(self):
 		import pandas as pd
@@ -711,7 +800,7 @@ class EcommerceBillImport(Document):
 			if self.jio_mart_items:
 				# Use getdate to handle ERPNext date parsing
 				self.jio_mart_items.sort(
-					key=lambda x: getdate(x.buyer_invoice_date) if x.buyer_invoice_date else frappe.utils.getdate("1900-01-01")
+					key=lambda x: parse_export_date(x.buyer_invoice_date) or frappe.utils.getdate("1900-01-01")
             )
 
 	@frappe.whitelist()
@@ -823,8 +912,11 @@ class EcommerceBillImport(Document):
 							# Parse the datetime and add 2 seconds
 							# invoice_datetime = datetime.strptime(str(items_data[0][1].get("invoice_date")), '%Y-%m-%d %H:%M:%S') if isinstance(items_data[0][1].get("invoice_date"), str) else items_data[0][1].get("invoice_date")
 							# invoice_datetime_plus_2 = invoice_datetime + timedelta(seconds=2)
-							si.posting_date = getdate(items_data[0][1].get("invoice_date"))
-							si.posting_time = get_time(items_data[0][1].get("invoice_date"))
+							invoice_dt = parse_export_datetime(items_data[0][1].get("invoice_date"))
+							if not invoice_dt:
+								raise Exception(f"Invalid Invoice Date: {items_data[0][1].get('invoice_date')}")
+							si.posting_date = invoice_dt.date()
+							si.posting_time = invoice_dt.time()
 							si.custom_inv_no = invoice_no
 							si.custom_ecommerce_invoice_id=invoice_no
 							# Avoid duplicate primary key errors if an invoice with this name already exists
@@ -912,15 +1004,17 @@ class EcommerceBillImport(Document):
 									("SGST",flt(child_row.sgst_rate)+flt(child_row.utgst_rate), flt(child_row.sgst_tax)+flt(child_row.utgst_tax), "Output Tax SGST - KGOPL"),
 									("IGST", flt(child_row.igst_rate),flt(child_row.igst_tax) ,"Output Tax IGST - KGOPL")
 									]:
-										if amount>0:
+										if amount:
+											rate = normalize_tax_rate(rate)
 											existing_tax = next((t for t in si.taxes if t.account_head == acc_head), None)
 											if existing_tax:
 												existing_tax.tax_amount += amount
+												existing_tax.rate = rate
 											else:
 												si.append("taxes", {
 													"charge_type": "On Net Total",
 													"account_head": acc_head,
-													"rate":rate,
+													"rate": rate,
 													"tax_amount": amount,
 													"description": tax_type
 												})
@@ -1026,8 +1120,13 @@ class EcommerceBillImport(Document):
 							si_return.customer = customer
 							si_return.set_posting_time = 1
 							# Parse the datetime and add 1 minute for returns
-							si_return.posting_date = getdate(refund_items[0][1].get("credit_note_date"))
-							si_return.posting_time = get_time(refund_items[0][1].get("credit_note_date"))
+							credit_note_dt = parse_export_datetime(refund_items[0][1].get("credit_note_date"))
+							if not credit_note_dt:
+								raise Exception(
+									f"Invalid Credit Note Date: {refund_items[0][1].get('credit_note_date')}"
+								)
+							si_return.posting_date = credit_note_dt.date()
+							si_return.posting_time = credit_note_dt.time()
 							si_return.custom_ecommerce_invoice_id = credit_note_no
 							# Avoid duplicate primary key errors if an invoice with this name already exists
 							existing_by_name = frappe.db.exists("Sales Invoice", credit_note_no)
@@ -1112,15 +1211,17 @@ class EcommerceBillImport(Document):
 									("SGST",flt(child_row.sgst_rate)+flt(child_row.utgst_rate), flt(child_row.sgst_tax)+flt(child_row.utgst_tax), "Output Tax SGST - KGOPL"),
 									("IGST", flt(child_row.igst_rate),flt(child_row.igst_tax) ,"Output Tax IGST - KGOPL")
 									]:
-										if amount>0:
+										if amount:
+											rate = normalize_tax_rate(rate)
 											existing_tax = next((t for t in si_return.taxes if t.account_head == acc_head), None)
 											if existing_tax:
 												existing_tax.tax_amount += amount
+												existing_tax.rate = rate
 											else:
 												si_return.append("taxes", {
 													"charge_type": "On Net Total",
 													"account_head": acc_head,
-													"rate":rate,
+													"rate": rate,
 													"tax_amount": amount,
 													"description": tax_type
 												})
@@ -1266,8 +1367,11 @@ class EcommerceBillImport(Document):
 						# Parse the datetime and add 2 seconds
 						# invoice_datetime = datetime.strptime(str(items_data[0][1].get("invoice_date")), '%Y-%m-%d %H:%M:%S') if isinstance(items_data[0][1].get("invoice_date"), str) else items_data[0][1].get("invoice_date")
 						# invoice_datetime_plus_2 = invoice_datetime + timedelta(seconds=2)
-						si.posting_date = getdate(items_data[0][1].get("invoice_date"))
-						si.posting_time = get_time(items_data[0][1].get("invoice_date"))
+						invoice_dt = parse_export_datetime(items_data[0][1].get("invoice_date"))
+						if not invoice_dt:
+							raise Exception(f"Invalid Invoice Date: {items_data[0][1].get('invoice_date')}")
+						si.posting_date = invoice_dt.date()
+						si.posting_time = invoice_dt.time()
 						si.custom_inv_no = invoice_no
 						si.custom_ecommerce_invoice_id = invoice_no
 						# Avoid duplicate primary key errors if an invoice with this name already exists
@@ -1361,15 +1465,17 @@ class EcommerceBillImport(Document):
 								("SGST", flt(child_row.sgst_rate) + flt(child_row.utgst_rate), flt(child_row.sgst_tax) + flt(child_row.utgst_tax), "Output Tax SGST - KGOPL"),
 								("IGST", flt(child_row.igst_rate), flt(child_row.igst_tax), "Output Tax IGST - KGOPL")
 							]:
-								if amount > 0:
+								if amount:
+									rate = normalize_tax_rate(rate)
 									existing_tax = next((t for t in si.taxes if t.account_head == acc_head), None)
 									if existing_tax:
 										existing_tax.tax_amount += amount
+										existing_tax.rate = rate
 									else:
 										si.append("taxes", {
 											"charge_type": "On Net Total",
 											"account_head": acc_head,
-											"rate": rate * 100,
+											"rate": rate,
 											"tax_amount": amount,
 											"description": tax_type
 										})
@@ -1485,8 +1591,13 @@ class EcommerceBillImport(Document):
 						si_return.set_posting_time = 1
 
 						# Parse the datetime and add 1 minute for returns
-						si_return.posting_date = getdate(refund_items[0][1].get("credit_note_date"))
-						si_return.posting_time = get_time(refund_items[0][1].get("credit_note_date"))
+						credit_note_dt = parse_export_datetime(refund_items[0][1].get("credit_note_date"))
+						if not credit_note_dt:
+							raise Exception(
+								f"Invalid Credit Note Date: {refund_items[0][1].get('credit_note_date')}"
+							)
+						si_return.posting_date = credit_note_dt.date()
+						si_return.posting_time = credit_note_dt.time()
 						si_return.custom_ecommerce_operator = self.ecommerce_mapping
 						si_return.custom_ecommerce_type = self.amazon_type
 						si_return.custom_inv_no = invoice_no
@@ -1574,15 +1685,17 @@ class EcommerceBillImport(Document):
 								("SGST", flt(child_row.sgst_rate) + flt(child_row.utgst_rate), flt(child_row.sgst_tax) + flt(child_row.utgst_tax), "Output Tax SGST - KGOPL"),
 								("IGST", flt(child_row.igst_rate), flt(child_row.igst_tax), "Output Tax IGST - KGOPL")
 							]:
-								if amount > 0:
+								if amount:
+									rate = normalize_tax_rate(rate)
 									existing_tax = next((t for t in si_return.taxes if t.account_head == acc_head), None)
 									if existing_tax:
 										existing_tax.tax_amount += amount
+										existing_tax.rate = rate
 									else:
 										si_return.append("taxes", {
 											"charge_type": "On Net Total",
 											"account_head": acc_head,
-											"rate": rate * 100,
+											"rate": rate,
 											"tax_amount": amount,
 											"description": tax_type
 										})
@@ -1727,8 +1840,11 @@ class EcommerceBillImport(Document):
 					# Parse the datetime and add 2 seconds
 					# invoice_datetime = datetime.strptime(str(group_rows[0][1].get("invoice_date")), '%Y-%m-%d %H:%M:%S') if isinstance(group_rows[0][1].get("invoice_date"), str) else group_rows[0][1].get("invoice_date")
 					# invoice_datetime_plus_2 = invoice_datetime + timedelta(seconds=2)
-					doc.posting_date = getdate(group_rows[0][1].get("invoice_date"))
-					doc.posting_time = get_time(group_rows[0][1].get("invoice_date"))
+					invoice_dt = parse_export_datetime(group_rows[0][1].get("invoice_date"))
+					if not invoice_dt:
+						raise Exception(f"Invalid Invoice Date: {group_rows[0][1].get('invoice_date')}")
+					doc.posting_date = invoice_dt.date()
+					doc.posting_time = invoice_dt.time()
 					doc.custom_inv_no = invoice_no
 					doc.custom_ecommerce_operator = self.ecommerce_mapping
 					doc.custom_ecommerce_type = self.amazon_type
@@ -1776,15 +1892,17 @@ class EcommerceBillImport(Document):
 								("SGST", flt(row.sgst_rate) + flt(row.utgst_rate), flt(row.sgst_amount) + flt(row.utgst_amount), "Output Tax SGST - KGOPL"),
 								("IGST", flt(row.igst_rate), flt(row.igst_amount), "Output Tax IGST - KGOPL")
 							]:
-								if amount > 0:
+								if amount:
+									rate = normalize_tax_rate(rate)
 									existing_tax = next((t for t in doc.taxes if t.account_head == acc_head), None)
 									if existing_tax:
 										existing_tax.tax_amount += amount
+										existing_tax.rate = rate
 									else:
 										doc.append("taxes", {
 											"charge_type": "On Net Total",
 											"account_head": acc_head,
-											"rate": rate * 100,
+											"rate": rate,
 											"tax_amount": amount,
 											"description": tax_type
 										})
@@ -1808,8 +1926,11 @@ class EcommerceBillImport(Document):
 					# Parse the datetime and add 2 seconds
 					# invoice_datetime = datetime.strptime(str(group_rows[0][1].get("invoice_date")), '%Y-%m-%d %H:%M:%S') if isinstance(group_rows[0][1].get("invoice_date"), str) else group_rows[0][1].get("invoice_date")
 					# invoice_datetime_plus_2 = invoice_datetime + timedelta(seconds=2)
-					pi_doc.posting_date = getdate(group_rows[0][1].get("invoice_date"))
-					pi_doc.posting_time = get_time(group_rows[0][1].get("invoice_date"))
+					invoice_dt = parse_export_datetime(group_rows[0][1].get("invoice_date"))
+					if not invoice_dt:
+						raise Exception(f"Invalid Invoice Date: {group_rows[0][1].get('invoice_date')}")
+					pi_doc.posting_date = invoice_dt.date()
+					pi_doc.posting_time = invoice_dt.time()
 					pi_doc.custom_inv_no = invoice_no
 					pi_doc.customer = customer
 					pi_doc.custom_ecommerce_operator = self.ecommerce_mapping
@@ -1863,15 +1984,17 @@ class EcommerceBillImport(Document):
 								("SGST", flt(row.sgst_rate) + flt(row.utgst_rate), flt(row.sgst_amount) + flt(row.utgst_amount), "Input Tax SGST - KGOPL"),
 								("IGST", flt(row.igst_rate), flt(row.igst_amount), "Input Tax IGST - KGOPL")
 							]:
-								if amount > 0:
+								if amount:
+									rate = normalize_tax_rate(rate)
 									existing_tax = next((t for t in pi_doc.taxes if t.account_head == acc_head), None)
 									if existing_tax:
 										existing_tax.tax_amount += amount
+										existing_tax.rate = rate
 									else:
 										pi_doc.append("taxes", {
 											"charge_type": "On Net Total",
 											"account_head": acc_head,
-											"rate": rate * 100,
+											"rate": rate,
 											"tax_amount": amount,
 											"description": tax_type
 										})
@@ -2034,7 +2157,7 @@ class EcommerceBillImport(Document):
 					si = frappe.new_doc("Sales Invoice")
 					si.customer = customer
 					si.set_posting_time = 1
-					si.posting_date = getdate(first.buyer_invoice_date)
+					si.posting_date = parse_export_date(first.buyer_invoice_date) or getdate(first.buyer_invoice_date)
 					si.custom_inv_no = invoice_key
 					si.custom_ecommerce_operator = self.ecommerce_mapping
 					si.custom_ecommerce_type = self.amazon_type
@@ -2271,7 +2394,7 @@ class EcommerceBillImport(Document):
 					si = frappe.new_doc("Sales Invoice")
 					si.customer = customer
 					si.set_posting_time = 1
-					si.posting_date = getdate(first.buyer_invoice_date)
+					si.posting_date = parse_export_date(first.buyer_invoice_date) or getdate(first.buyer_invoice_date)
 					si.custom_inv_no = invoice_key
 					si.custom_ecommerce_operator = self.ecommerce_mapping
 					si.custom_ecommerce_type = self.amazon_type
@@ -2599,11 +2722,11 @@ class EcommerceBillImport(Document):
 		invoice_groups = {}
 		for row_idx, row in df.iterrows():
 			if is_cancelled_row(row):
-				continue
+					continue
 
 			invoice_no = get_invoice_no(row)
 			if not invoice_no:
-				continue
+					continue
 
 			invoice_groups.setdefault(invoice_no, []).append((row_idx + 1, row))
 
@@ -2778,7 +2901,7 @@ class EcommerceBillImport(Document):
 							"qty": qty,
 							"rate": rate,
 							"description": product_name,
-							"warehouse": warehouse,
+					"warehouse": warehouse,
 							"gst_hsn_code": hsn_code,
 							"income_account": cred_mapping.income_account,
 							"custom_ecom_item_id": item_id,
@@ -2799,7 +2922,7 @@ class EcommerceBillImport(Document):
 						if seller_state_code and customer_state_code and seller_state_code == customer_state_code:
 							tax_totals["cgst"] += row_tax_amount / 2
 							tax_totals["sgst"] += row_tax_amount / 2
-						else:
+				else:
 							tax_totals["igst"] += row_tax_amount
 
 				# Reset and apply taxes (Actual) based on totals
@@ -2837,7 +2960,7 @@ class EcommerceBillImport(Document):
 							"description": "IGST",
 						},
 					)
-
+			
 				# Save + submit (deterministic per invoice group)
 				si.save(ignore_permissions=True)
 				for it in si.items:
@@ -2872,13 +2995,13 @@ class EcommerceBillImport(Document):
 		# Final status + progress
 		self.error_json = json.dumps(errors) if errors else ""
 		if errors and success_invoices:
-			self.status = "Partial Success"
+				self.status = "Partial Success"
 		elif errors and not success_invoices:
-			self.status = "Error"
+				self.status = "Error"
 		else:
 			self.status = "Success"
 
-		self.save(ignore_permissions=True)
+			self.save(ignore_permissions=True)
 
 		self._publish_progress(
 			current=total_invoices,
@@ -3015,7 +3138,7 @@ class EcommerceBillImport(Document):
 					si = frappe.new_doc("Sales Invoice")
 					si.customer = customer
 					si.set_posting_time = 1
-					si.posting_date = getdate(first.buyer_invoice_date)
+					si.posting_date = parse_export_date(first.buyer_invoice_date) or getdate(first.buyer_invoice_date)
 					si.custom_inv_no = invoice_key
 					si.custom_ecommerce_operator = self.ecommerce_mapping
 					si.custom_ecommerce_type = self.amazon_type
@@ -3242,7 +3365,7 @@ class EcommerceBillImport(Document):
 					si = frappe.new_doc("Sales Invoice")
 					si.customer = customer
 					si.set_posting_time = 1
-					si.posting_date = getdate(first.buyer_invoice_date)
+					si.posting_date = parse_export_date(first.buyer_invoice_date) or getdate(first.buyer_invoice_date)
 					si.custom_inv_no = invoice_key
 					si.custom_ecommerce_operator = self.ecommerce_mapping
 					si.custom_ecommerce_type = self.amazon_type
